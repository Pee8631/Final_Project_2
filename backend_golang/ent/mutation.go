// Code generated by entc, DO NOT EDIT.

package ent

import (
	"FinalProject/ent/appointment"
	"FinalProject/ent/certification"
	"FinalProject/ent/chat"
	"FinalProject/ent/department"
	"FinalProject/ent/disease"
	"FinalProject/ent/hospital"
	"FinalProject/ent/message"
	"FinalProject/ent/notification"
	"FinalProject/ent/pinfo"
	"FinalProject/ent/predicate"
	"FinalProject/ent/role"
	"FinalProject/ent/schedule"
	"FinalProject/ent/telecom"
	"FinalProject/ent/token"
	"FinalProject/ent/treatment"
	"FinalProject/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointment   = "Appointment"
	TypeCertification = "Certification"
	TypeChat          = "Chat"
	TypeDepartment    = "Department"
	TypeDisease       = "Disease"
	TypeHospital      = "Hospital"
	TypeMessage       = "Message"
	TypeNotification  = "Notification"
	TypePInfo         = "PInfo"
	TypeRole          = "Role"
	TypeSchedule      = "Schedule"
	TypeTelecom       = "Telecom"
	TypeToken         = "Token"
	TypeTreatment     = "Treatment"
	TypeUser          = "User"
)

// AppointmentMutation represents an operation that mutates the Appointment nodes in the graph.
type AppointmentMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	reasonForAppointment        *string
	detail                      *string
	startTime                   *time.Time
	endTime                     *time.Time
	status                      *string
	_DoctorId                   *int
	add_DoctorId                *int
	_UserId                     *int
	add_UserId                  *int
	clearedFields               map[string]struct{}
	appointment_schedule        *int
	clearedappointment_schedule bool
	appointment_chat            *int
	clearedappointment_chat     bool
	done                        bool
	oldValue                    func(context.Context) (*Appointment, error)
	predicates                  []predicate.Appointment
}

var _ ent.Mutation = (*AppointmentMutation)(nil)

// appointmentOption allows management of the mutation configuration using functional options.
type appointmentOption func(*AppointmentMutation)

// newAppointmentMutation creates new mutation for the Appointment entity.
func newAppointmentMutation(c config, op Op, opts ...appointmentOption) *AppointmentMutation {
	m := &AppointmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentID sets the ID field of the mutation.
func withAppointmentID(id int) appointmentOption {
	return func(m *AppointmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Appointment
		)
		m.oldValue = func(ctx context.Context) (*Appointment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Appointment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointment sets the old Appointment of the mutation.
func withAppointment(node *Appointment) appointmentOption {
	return func(m *AppointmentMutation) {
		m.oldValue = func(context.Context) (*Appointment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppointmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppointmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Appointment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReasonForAppointment sets the "reasonForAppointment" field.
func (m *AppointmentMutation) SetReasonForAppointment(s string) {
	m.reasonForAppointment = &s
}

// ReasonForAppointment returns the value of the "reasonForAppointment" field in the mutation.
func (m *AppointmentMutation) ReasonForAppointment() (r string, exists bool) {
	v := m.reasonForAppointment
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonForAppointment returns the old "reasonForAppointment" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldReasonForAppointment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReasonForAppointment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReasonForAppointment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonForAppointment: %w", err)
	}
	return oldValue.ReasonForAppointment, nil
}

// ResetReasonForAppointment resets all changes to the "reasonForAppointment" field.
func (m *AppointmentMutation) ResetReasonForAppointment() {
	m.reasonForAppointment = nil
}

// SetDetail sets the "detail" field.
func (m *AppointmentMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *AppointmentMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *AppointmentMutation) ResetDetail() {
	m.detail = nil
}

// SetStartTime sets the "startTime" field.
func (m *AppointmentMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *AppointmentMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *AppointmentMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *AppointmentMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *AppointmentMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *AppointmentMutation) ResetEndTime() {
	m.endTime = nil
}

// SetStatus sets the "status" field.
func (m *AppointmentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AppointmentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppointmentMutation) ResetStatus() {
	m.status = nil
}

// SetDoctorId sets the "DoctorId" field.
func (m *AppointmentMutation) SetDoctorId(i int) {
	m._DoctorId = &i
	m.add_DoctorId = nil
}

// DoctorId returns the value of the "DoctorId" field in the mutation.
func (m *AppointmentMutation) DoctorId() (r int, exists bool) {
	v := m._DoctorId
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorId returns the old "DoctorId" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldDoctorId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoctorId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoctorId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorId: %w", err)
	}
	return oldValue.DoctorId, nil
}

// AddDoctorId adds i to the "DoctorId" field.
func (m *AppointmentMutation) AddDoctorId(i int) {
	if m.add_DoctorId != nil {
		*m.add_DoctorId += i
	} else {
		m.add_DoctorId = &i
	}
}

// AddedDoctorId returns the value that was added to the "DoctorId" field in this mutation.
func (m *AppointmentMutation) AddedDoctorId() (r int, exists bool) {
	v := m.add_DoctorId
	if v == nil {
		return
	}
	return *v, true
}

// ResetDoctorId resets all changes to the "DoctorId" field.
func (m *AppointmentMutation) ResetDoctorId() {
	m._DoctorId = nil
	m.add_DoctorId = nil
}

// SetUserId sets the "UserId" field.
func (m *AppointmentMutation) SetUserId(i int) {
	m._UserId = &i
	m.add_UserId = nil
}

// UserId returns the value of the "UserId" field in the mutation.
func (m *AppointmentMutation) UserId() (r int, exists bool) {
	v := m._UserId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "UserId" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "UserId" field.
func (m *AppointmentMutation) AddUserId(i int) {
	if m.add_UserId != nil {
		*m.add_UserId += i
	} else {
		m.add_UserId = &i
	}
}

// AddedUserId returns the value that was added to the "UserId" field in this mutation.
func (m *AppointmentMutation) AddedUserId() (r int, exists bool) {
	v := m.add_UserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "UserId" field.
func (m *AppointmentMutation) ResetUserId() {
	m._UserId = nil
	m.add_UserId = nil
}

// SetAppointmentScheduleID sets the "appointment_schedule" edge to the Schedule entity by id.
func (m *AppointmentMutation) SetAppointmentScheduleID(id int) {
	m.appointment_schedule = &id
}

// ClearAppointmentSchedule clears the "appointment_schedule" edge to the Schedule entity.
func (m *AppointmentMutation) ClearAppointmentSchedule() {
	m.clearedappointment_schedule = true
}

// AppointmentScheduleCleared reports if the "appointment_schedule" edge to the Schedule entity was cleared.
func (m *AppointmentMutation) AppointmentScheduleCleared() bool {
	return m.clearedappointment_schedule
}

// AppointmentScheduleID returns the "appointment_schedule" edge ID in the mutation.
func (m *AppointmentMutation) AppointmentScheduleID() (id int, exists bool) {
	if m.appointment_schedule != nil {
		return *m.appointment_schedule, true
	}
	return
}

// AppointmentScheduleIDs returns the "appointment_schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentScheduleID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) AppointmentScheduleIDs() (ids []int) {
	if id := m.appointment_schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentSchedule resets all changes to the "appointment_schedule" edge.
func (m *AppointmentMutation) ResetAppointmentSchedule() {
	m.appointment_schedule = nil
	m.clearedappointment_schedule = false
}

// SetAppointmentChatID sets the "appointment_chat" edge to the Chat entity by id.
func (m *AppointmentMutation) SetAppointmentChatID(id int) {
	m.appointment_chat = &id
}

// ClearAppointmentChat clears the "appointment_chat" edge to the Chat entity.
func (m *AppointmentMutation) ClearAppointmentChat() {
	m.clearedappointment_chat = true
}

// AppointmentChatCleared reports if the "appointment_chat" edge to the Chat entity was cleared.
func (m *AppointmentMutation) AppointmentChatCleared() bool {
	return m.clearedappointment_chat
}

// AppointmentChatID returns the "appointment_chat" edge ID in the mutation.
func (m *AppointmentMutation) AppointmentChatID() (id int, exists bool) {
	if m.appointment_chat != nil {
		return *m.appointment_chat, true
	}
	return
}

// AppointmentChatIDs returns the "appointment_chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppointmentChatID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) AppointmentChatIDs() (ids []int) {
	if id := m.appointment_chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppointmentChat resets all changes to the "appointment_chat" edge.
func (m *AppointmentMutation) ResetAppointmentChat() {
	m.appointment_chat = nil
	m.clearedappointment_chat = false
}

// Where appends a list predicates to the AppointmentMutation builder.
func (m *AppointmentMutation) Where(ps ...predicate.Appointment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppointmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Appointment).
func (m *AppointmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppointmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.reasonForAppointment != nil {
		fields = append(fields, appointment.FieldReasonForAppointment)
	}
	if m.detail != nil {
		fields = append(fields, appointment.FieldDetail)
	}
	if m.startTime != nil {
		fields = append(fields, appointment.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, appointment.FieldEndTime)
	}
	if m.status != nil {
		fields = append(fields, appointment.FieldStatus)
	}
	if m._DoctorId != nil {
		fields = append(fields, appointment.FieldDoctorId)
	}
	if m._UserId != nil {
		fields = append(fields, appointment.FieldUserId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppointmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldReasonForAppointment:
		return m.ReasonForAppointment()
	case appointment.FieldDetail:
		return m.Detail()
	case appointment.FieldStartTime:
		return m.StartTime()
	case appointment.FieldEndTime:
		return m.EndTime()
	case appointment.FieldStatus:
		return m.Status()
	case appointment.FieldDoctorId:
		return m.DoctorId()
	case appointment.FieldUserId:
		return m.UserId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppointmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointment.FieldReasonForAppointment:
		return m.OldReasonForAppointment(ctx)
	case appointment.FieldDetail:
		return m.OldDetail(ctx)
	case appointment.FieldStartTime:
		return m.OldStartTime(ctx)
	case appointment.FieldEndTime:
		return m.OldEndTime(ctx)
	case appointment.FieldStatus:
		return m.OldStatus(ctx)
	case appointment.FieldDoctorId:
		return m.OldDoctorId(ctx)
	case appointment.FieldUserId:
		return m.OldUserId(ctx)
	}
	return nil, fmt.Errorf("unknown Appointment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldReasonForAppointment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonForAppointment(v)
		return nil
	case appointment.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case appointment.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case appointment.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case appointment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case appointment.FieldDoctorId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorId(v)
		return nil
	case appointment.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppointmentMutation) AddedFields() []string {
	var fields []string
	if m.add_DoctorId != nil {
		fields = append(fields, appointment.FieldDoctorId)
	}
	if m.add_UserId != nil {
		fields = append(fields, appointment.FieldUserId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppointmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldDoctorId:
		return m.AddedDoctorId()
	case appointment.FieldUserId:
		return m.AddedUserId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldDoctorId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoctorId(v)
		return nil
	case appointment.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppointmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppointmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Appointment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppointmentMutation) ResetField(name string) error {
	switch name {
	case appointment.FieldReasonForAppointment:
		m.ResetReasonForAppointment()
		return nil
	case appointment.FieldDetail:
		m.ResetDetail()
		return nil
	case appointment.FieldStartTime:
		m.ResetStartTime()
		return nil
	case appointment.FieldEndTime:
		m.ResetEndTime()
		return nil
	case appointment.FieldStatus:
		m.ResetStatus()
		return nil
	case appointment.FieldDoctorId:
		m.ResetDoctorId()
		return nil
	case appointment.FieldUserId:
		m.ResetUserId()
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppointmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appointment_schedule != nil {
		edges = append(edges, appointment.EdgeAppointmentSchedule)
	}
	if m.appointment_chat != nil {
		edges = append(edges, appointment.EdgeAppointmentChat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppointmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointment.EdgeAppointmentSchedule:
		if id := m.appointment_schedule; id != nil {
			return []ent.Value{*id}
		}
	case appointment.EdgeAppointmentChat:
		if id := m.appointment_chat; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppointmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppointmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppointmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappointment_schedule {
		edges = append(edges, appointment.EdgeAppointmentSchedule)
	}
	if m.clearedappointment_chat {
		edges = append(edges, appointment.EdgeAppointmentChat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppointmentMutation) EdgeCleared(name string) bool {
	switch name {
	case appointment.EdgeAppointmentSchedule:
		return m.clearedappointment_schedule
	case appointment.EdgeAppointmentChat:
		return m.clearedappointment_chat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppointmentMutation) ClearEdge(name string) error {
	switch name {
	case appointment.EdgeAppointmentSchedule:
		m.ClearAppointmentSchedule()
		return nil
	case appointment.EdgeAppointmentChat:
		m.ClearAppointmentChat()
		return nil
	}
	return fmt.Errorf("unknown Appointment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppointmentMutation) ResetEdge(name string) error {
	switch name {
	case appointment.EdgeAppointmentSchedule:
		m.ResetAppointmentSchedule()
		return nil
	case appointment.EdgeAppointmentChat:
		m.ResetAppointmentChat()
		return nil
	}
	return fmt.Errorf("unknown Appointment edge %s", name)
}

// CertificationMutation represents an operation that mutates the Certification nodes in the graph.
type CertificationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	code                *string
	diloma              *string
	dateOfIssuing       *time.Time
	dateOfExp           *time.Time
	_Issuer             *string
	clearedFields       map[string]struct{}
	doctor_owner        *int
	cleareddoctor_owner bool
	done                bool
	oldValue            func(context.Context) (*Certification, error)
	predicates          []predicate.Certification
}

var _ ent.Mutation = (*CertificationMutation)(nil)

// certificationOption allows management of the mutation configuration using functional options.
type certificationOption func(*CertificationMutation)

// newCertificationMutation creates new mutation for the Certification entity.
func newCertificationMutation(c config, op Op, opts ...certificationOption) *CertificationMutation {
	m := &CertificationMutation{
		config:        c,
		op:            op,
		typ:           TypeCertification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificationID sets the ID field of the mutation.
func withCertificationID(id int) certificationOption {
	return func(m *CertificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Certification
		)
		m.oldValue = func(ctx context.Context) (*Certification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertification sets the old Certification of the mutation.
func withCertification(node *Certification) certificationOption {
	return func(m *CertificationMutation) {
		m.oldValue = func(context.Context) (*Certification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CertificationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CertificationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CertificationMutation) ResetCode() {
	m.code = nil
}

// SetDiloma sets the "diloma" field.
func (m *CertificationMutation) SetDiloma(s string) {
	m.diloma = &s
}

// Diloma returns the value of the "diloma" field in the mutation.
func (m *CertificationMutation) Diloma() (r string, exists bool) {
	v := m.diloma
	if v == nil {
		return
	}
	return *v, true
}

// OldDiloma returns the old "diloma" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldDiloma(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiloma is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiloma requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiloma: %w", err)
	}
	return oldValue.Diloma, nil
}

// ResetDiloma resets all changes to the "diloma" field.
func (m *CertificationMutation) ResetDiloma() {
	m.diloma = nil
}

// SetDateOfIssuing sets the "dateOfIssuing" field.
func (m *CertificationMutation) SetDateOfIssuing(t time.Time) {
	m.dateOfIssuing = &t
}

// DateOfIssuing returns the value of the "dateOfIssuing" field in the mutation.
func (m *CertificationMutation) DateOfIssuing() (r time.Time, exists bool) {
	v := m.dateOfIssuing
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfIssuing returns the old "dateOfIssuing" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldDateOfIssuing(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfIssuing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfIssuing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfIssuing: %w", err)
	}
	return oldValue.DateOfIssuing, nil
}

// ClearDateOfIssuing clears the value of the "dateOfIssuing" field.
func (m *CertificationMutation) ClearDateOfIssuing() {
	m.dateOfIssuing = nil
	m.clearedFields[certification.FieldDateOfIssuing] = struct{}{}
}

// DateOfIssuingCleared returns if the "dateOfIssuing" field was cleared in this mutation.
func (m *CertificationMutation) DateOfIssuingCleared() bool {
	_, ok := m.clearedFields[certification.FieldDateOfIssuing]
	return ok
}

// ResetDateOfIssuing resets all changes to the "dateOfIssuing" field.
func (m *CertificationMutation) ResetDateOfIssuing() {
	m.dateOfIssuing = nil
	delete(m.clearedFields, certification.FieldDateOfIssuing)
}

// SetDateOfExp sets the "dateOfExp" field.
func (m *CertificationMutation) SetDateOfExp(t time.Time) {
	m.dateOfExp = &t
}

// DateOfExp returns the value of the "dateOfExp" field in the mutation.
func (m *CertificationMutation) DateOfExp() (r time.Time, exists bool) {
	v := m.dateOfExp
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfExp returns the old "dateOfExp" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldDateOfExp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfExp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfExp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfExp: %w", err)
	}
	return oldValue.DateOfExp, nil
}

// ClearDateOfExp clears the value of the "dateOfExp" field.
func (m *CertificationMutation) ClearDateOfExp() {
	m.dateOfExp = nil
	m.clearedFields[certification.FieldDateOfExp] = struct{}{}
}

// DateOfExpCleared returns if the "dateOfExp" field was cleared in this mutation.
func (m *CertificationMutation) DateOfExpCleared() bool {
	_, ok := m.clearedFields[certification.FieldDateOfExp]
	return ok
}

// ResetDateOfExp resets all changes to the "dateOfExp" field.
func (m *CertificationMutation) ResetDateOfExp() {
	m.dateOfExp = nil
	delete(m.clearedFields, certification.FieldDateOfExp)
}

// SetIssuer sets the "Issuer" field.
func (m *CertificationMutation) SetIssuer(s string) {
	m._Issuer = &s
}

// Issuer returns the value of the "Issuer" field in the mutation.
func (m *CertificationMutation) Issuer() (r string, exists bool) {
	v := m._Issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "Issuer" field's value of the Certification entity.
// If the Certification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificationMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer resets all changes to the "Issuer" field.
func (m *CertificationMutation) ResetIssuer() {
	m._Issuer = nil
}

// SetDoctorOwnerID sets the "doctor_owner" edge to the User entity by id.
func (m *CertificationMutation) SetDoctorOwnerID(id int) {
	m.doctor_owner = &id
}

// ClearDoctorOwner clears the "doctor_owner" edge to the User entity.
func (m *CertificationMutation) ClearDoctorOwner() {
	m.cleareddoctor_owner = true
}

// DoctorOwnerCleared reports if the "doctor_owner" edge to the User entity was cleared.
func (m *CertificationMutation) DoctorOwnerCleared() bool {
	return m.cleareddoctor_owner
}

// DoctorOwnerID returns the "doctor_owner" edge ID in the mutation.
func (m *CertificationMutation) DoctorOwnerID() (id int, exists bool) {
	if m.doctor_owner != nil {
		return *m.doctor_owner, true
	}
	return
}

// DoctorOwnerIDs returns the "doctor_owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DoctorOwnerID instead. It exists only for internal usage by the builders.
func (m *CertificationMutation) DoctorOwnerIDs() (ids []int) {
	if id := m.doctor_owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctorOwner resets all changes to the "doctor_owner" edge.
func (m *CertificationMutation) ResetDoctorOwner() {
	m.doctor_owner = nil
	m.cleareddoctor_owner = false
}

// Where appends a list predicates to the CertificationMutation builder.
func (m *CertificationMutation) Where(ps ...predicate.Certification) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CertificationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Certification).
func (m *CertificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, certification.FieldCode)
	}
	if m.diloma != nil {
		fields = append(fields, certification.FieldDiloma)
	}
	if m.dateOfIssuing != nil {
		fields = append(fields, certification.FieldDateOfIssuing)
	}
	if m.dateOfExp != nil {
		fields = append(fields, certification.FieldDateOfExp)
	}
	if m._Issuer != nil {
		fields = append(fields, certification.FieldIssuer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certification.FieldCode:
		return m.Code()
	case certification.FieldDiloma:
		return m.Diloma()
	case certification.FieldDateOfIssuing:
		return m.DateOfIssuing()
	case certification.FieldDateOfExp:
		return m.DateOfExp()
	case certification.FieldIssuer:
		return m.Issuer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certification.FieldCode:
		return m.OldCode(ctx)
	case certification.FieldDiloma:
		return m.OldDiloma(ctx)
	case certification.FieldDateOfIssuing:
		return m.OldDateOfIssuing(ctx)
	case certification.FieldDateOfExp:
		return m.OldDateOfExp(ctx)
	case certification.FieldIssuer:
		return m.OldIssuer(ctx)
	}
	return nil, fmt.Errorf("unknown Certification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certification.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case certification.FieldDiloma:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiloma(v)
		return nil
	case certification.FieldDateOfIssuing:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfIssuing(v)
		return nil
	case certification.FieldDateOfExp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfExp(v)
		return nil
	case certification.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certification.FieldDateOfIssuing) {
		fields = append(fields, certification.FieldDateOfIssuing)
	}
	if m.FieldCleared(certification.FieldDateOfExp) {
		fields = append(fields, certification.FieldDateOfExp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificationMutation) ClearField(name string) error {
	switch name {
	case certification.FieldDateOfIssuing:
		m.ClearDateOfIssuing()
		return nil
	case certification.FieldDateOfExp:
		m.ClearDateOfExp()
		return nil
	}
	return fmt.Errorf("unknown Certification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificationMutation) ResetField(name string) error {
	switch name {
	case certification.FieldCode:
		m.ResetCode()
		return nil
	case certification.FieldDiloma:
		m.ResetDiloma()
		return nil
	case certification.FieldDateOfIssuing:
		m.ResetDateOfIssuing()
		return nil
	case certification.FieldDateOfExp:
		m.ResetDateOfExp()
		return nil
	case certification.FieldIssuer:
		m.ResetIssuer()
		return nil
	}
	return fmt.Errorf("unknown Certification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctor_owner != nil {
		edges = append(edges, certification.EdgeDoctorOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certification.EdgeDoctorOwner:
		if id := m.doctor_owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddoctor_owner {
		edges = append(edges, certification.EdgeDoctorOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificationMutation) EdgeCleared(name string) bool {
	switch name {
	case certification.EdgeDoctorOwner:
		return m.cleareddoctor_owner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificationMutation) ClearEdge(name string) error {
	switch name {
	case certification.EdgeDoctorOwner:
		m.ClearDoctorOwner()
		return nil
	}
	return fmt.Errorf("unknown Certification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificationMutation) ResetEdge(name string) error {
	switch name {
	case certification.EdgeDoctorOwner:
		m.ResetDoctorOwner()
		return nil
	}
	return fmt.Errorf("unknown Certification edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_Chat_room_name         *string
	_IsLockChat             *bool
	clearedFields           map[string]struct{}
	chat_user               map[int]struct{}
	removedchat_user        map[int]struct{}
	clearedchat_user        bool
	chat_message            map[int]struct{}
	removedchat_message     map[int]struct{}
	clearedchat_message     bool
	chat_appointment        map[int]struct{}
	removedchat_appointment map[int]struct{}
	clearedchat_appointment bool
	done                    bool
	oldValue                func(context.Context) (*Chat, error)
	predicates              []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id int) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChatRoomName sets the "Chat_room_name" field.
func (m *ChatMutation) SetChatRoomName(s string) {
	m._Chat_room_name = &s
}

// ChatRoomName returns the value of the "Chat_room_name" field in the mutation.
func (m *ChatMutation) ChatRoomName() (r string, exists bool) {
	v := m._Chat_room_name
	if v == nil {
		return
	}
	return *v, true
}

// OldChatRoomName returns the old "Chat_room_name" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldChatRoomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatRoomName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatRoomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatRoomName: %w", err)
	}
	return oldValue.ChatRoomName, nil
}

// ResetChatRoomName resets all changes to the "Chat_room_name" field.
func (m *ChatMutation) ResetChatRoomName() {
	m._Chat_room_name = nil
}

// SetIsLockChat sets the "IsLockChat" field.
func (m *ChatMutation) SetIsLockChat(b bool) {
	m._IsLockChat = &b
}

// IsLockChat returns the value of the "IsLockChat" field in the mutation.
func (m *ChatMutation) IsLockChat() (r bool, exists bool) {
	v := m._IsLockChat
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLockChat returns the old "IsLockChat" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldIsLockChat(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLockChat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLockChat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLockChat: %w", err)
	}
	return oldValue.IsLockChat, nil
}

// ResetIsLockChat resets all changes to the "IsLockChat" field.
func (m *ChatMutation) ResetIsLockChat() {
	m._IsLockChat = nil
}

// AddChatUserIDs adds the "chat_user" edge to the User entity by ids.
func (m *ChatMutation) AddChatUserIDs(ids ...int) {
	if m.chat_user == nil {
		m.chat_user = make(map[int]struct{})
	}
	for i := range ids {
		m.chat_user[ids[i]] = struct{}{}
	}
}

// ClearChatUser clears the "chat_user" edge to the User entity.
func (m *ChatMutation) ClearChatUser() {
	m.clearedchat_user = true
}

// ChatUserCleared reports if the "chat_user" edge to the User entity was cleared.
func (m *ChatMutation) ChatUserCleared() bool {
	return m.clearedchat_user
}

// RemoveChatUserIDs removes the "chat_user" edge to the User entity by IDs.
func (m *ChatMutation) RemoveChatUserIDs(ids ...int) {
	if m.removedchat_user == nil {
		m.removedchat_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chat_user, ids[i])
		m.removedchat_user[ids[i]] = struct{}{}
	}
}

// RemovedChatUser returns the removed IDs of the "chat_user" edge to the User entity.
func (m *ChatMutation) RemovedChatUserIDs() (ids []int) {
	for id := range m.removedchat_user {
		ids = append(ids, id)
	}
	return
}

// ChatUserIDs returns the "chat_user" edge IDs in the mutation.
func (m *ChatMutation) ChatUserIDs() (ids []int) {
	for id := range m.chat_user {
		ids = append(ids, id)
	}
	return
}

// ResetChatUser resets all changes to the "chat_user" edge.
func (m *ChatMutation) ResetChatUser() {
	m.chat_user = nil
	m.clearedchat_user = false
	m.removedchat_user = nil
}

// AddChatMessageIDs adds the "chat_message" edge to the Message entity by ids.
func (m *ChatMutation) AddChatMessageIDs(ids ...int) {
	if m.chat_message == nil {
		m.chat_message = make(map[int]struct{})
	}
	for i := range ids {
		m.chat_message[ids[i]] = struct{}{}
	}
}

// ClearChatMessage clears the "chat_message" edge to the Message entity.
func (m *ChatMutation) ClearChatMessage() {
	m.clearedchat_message = true
}

// ChatMessageCleared reports if the "chat_message" edge to the Message entity was cleared.
func (m *ChatMutation) ChatMessageCleared() bool {
	return m.clearedchat_message
}

// RemoveChatMessageIDs removes the "chat_message" edge to the Message entity by IDs.
func (m *ChatMutation) RemoveChatMessageIDs(ids ...int) {
	if m.removedchat_message == nil {
		m.removedchat_message = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chat_message, ids[i])
		m.removedchat_message[ids[i]] = struct{}{}
	}
}

// RemovedChatMessage returns the removed IDs of the "chat_message" edge to the Message entity.
func (m *ChatMutation) RemovedChatMessageIDs() (ids []int) {
	for id := range m.removedchat_message {
		ids = append(ids, id)
	}
	return
}

// ChatMessageIDs returns the "chat_message" edge IDs in the mutation.
func (m *ChatMutation) ChatMessageIDs() (ids []int) {
	for id := range m.chat_message {
		ids = append(ids, id)
	}
	return
}

// ResetChatMessage resets all changes to the "chat_message" edge.
func (m *ChatMutation) ResetChatMessage() {
	m.chat_message = nil
	m.clearedchat_message = false
	m.removedchat_message = nil
}

// AddChatAppointmentIDs adds the "chat_appointment" edge to the Appointment entity by ids.
func (m *ChatMutation) AddChatAppointmentIDs(ids ...int) {
	if m.chat_appointment == nil {
		m.chat_appointment = make(map[int]struct{})
	}
	for i := range ids {
		m.chat_appointment[ids[i]] = struct{}{}
	}
}

// ClearChatAppointment clears the "chat_appointment" edge to the Appointment entity.
func (m *ChatMutation) ClearChatAppointment() {
	m.clearedchat_appointment = true
}

// ChatAppointmentCleared reports if the "chat_appointment" edge to the Appointment entity was cleared.
func (m *ChatMutation) ChatAppointmentCleared() bool {
	return m.clearedchat_appointment
}

// RemoveChatAppointmentIDs removes the "chat_appointment" edge to the Appointment entity by IDs.
func (m *ChatMutation) RemoveChatAppointmentIDs(ids ...int) {
	if m.removedchat_appointment == nil {
		m.removedchat_appointment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chat_appointment, ids[i])
		m.removedchat_appointment[ids[i]] = struct{}{}
	}
}

// RemovedChatAppointment returns the removed IDs of the "chat_appointment" edge to the Appointment entity.
func (m *ChatMutation) RemovedChatAppointmentIDs() (ids []int) {
	for id := range m.removedchat_appointment {
		ids = append(ids, id)
	}
	return
}

// ChatAppointmentIDs returns the "chat_appointment" edge IDs in the mutation.
func (m *ChatMutation) ChatAppointmentIDs() (ids []int) {
	for id := range m.chat_appointment {
		ids = append(ids, id)
	}
	return
}

// ResetChatAppointment resets all changes to the "chat_appointment" edge.
func (m *ChatMutation) ResetChatAppointment() {
	m.chat_appointment = nil
	m.clearedchat_appointment = false
	m.removedchat_appointment = nil
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Chat_room_name != nil {
		fields = append(fields, chat.FieldChatRoomName)
	}
	if m._IsLockChat != nil {
		fields = append(fields, chat.FieldIsLockChat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldChatRoomName:
		return m.ChatRoomName()
	case chat.FieldIsLockChat:
		return m.IsLockChat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chat.FieldChatRoomName:
		return m.OldChatRoomName(ctx)
	case chat.FieldIsLockChat:
		return m.OldIsLockChat(ctx)
	}
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chat.FieldChatRoomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatRoomName(v)
		return nil
	case chat.FieldIsLockChat:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLockChat(v)
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	switch name {
	case chat.FieldChatRoomName:
		m.ResetChatRoomName()
		return nil
	case chat.FieldIsLockChat:
		m.ResetIsLockChat()
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.chat_user != nil {
		edges = append(edges, chat.EdgeChatUser)
	}
	if m.chat_message != nil {
		edges = append(edges, chat.EdgeChatMessage)
	}
	if m.chat_appointment != nil {
		edges = append(edges, chat.EdgeChatAppointment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeChatUser:
		ids := make([]ent.Value, 0, len(m.chat_user))
		for id := range m.chat_user {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeChatMessage:
		ids := make([]ent.Value, 0, len(m.chat_message))
		for id := range m.chat_message {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeChatAppointment:
		ids := make([]ent.Value, 0, len(m.chat_appointment))
		for id := range m.chat_appointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchat_user != nil {
		edges = append(edges, chat.EdgeChatUser)
	}
	if m.removedchat_message != nil {
		edges = append(edges, chat.EdgeChatMessage)
	}
	if m.removedchat_appointment != nil {
		edges = append(edges, chat.EdgeChatAppointment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeChatUser:
		ids := make([]ent.Value, 0, len(m.removedchat_user))
		for id := range m.removedchat_user {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeChatMessage:
		ids := make([]ent.Value, 0, len(m.removedchat_message))
		for id := range m.removedchat_message {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeChatAppointment:
		ids := make([]ent.Value, 0, len(m.removedchat_appointment))
		for id := range m.removedchat_appointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchat_user {
		edges = append(edges, chat.EdgeChatUser)
	}
	if m.clearedchat_message {
		edges = append(edges, chat.EdgeChatMessage)
	}
	if m.clearedchat_appointment {
		edges = append(edges, chat.EdgeChatAppointment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	switch name {
	case chat.EdgeChatUser:
		return m.clearedchat_user
	case chat.EdgeChatMessage:
		return m.clearedchat_message
	case chat.EdgeChatAppointment:
		return m.clearedchat_appointment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	switch name {
	case chat.EdgeChatUser:
		m.ResetChatUser()
		return nil
	case chat.EdgeChatMessage:
		m.ResetChatMessage()
		return nil
	case chat.EdgeChatAppointment:
		m.ResetChatAppointment()
		return nil
	}
	return fmt.Errorf("unknown Chat edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	image                        *string
	clearedFields                map[string]struct{}
	department_has_doctor        map[int]struct{}
	removeddepartment_has_doctor map[int]struct{}
	cleareddepartment_has_doctor bool
	done                         bool
	oldValue                     func(context.Context) (*Department, error)
	predicates                   []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *DepartmentMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *DepartmentMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *DepartmentMutation) ResetImage() {
	m.image = nil
}

// AddDepartmentHasDoctorIDs adds the "department_has_doctor" edge to the User entity by ids.
func (m *DepartmentMutation) AddDepartmentHasDoctorIDs(ids ...int) {
	if m.department_has_doctor == nil {
		m.department_has_doctor = make(map[int]struct{})
	}
	for i := range ids {
		m.department_has_doctor[ids[i]] = struct{}{}
	}
}

// ClearDepartmentHasDoctor clears the "department_has_doctor" edge to the User entity.
func (m *DepartmentMutation) ClearDepartmentHasDoctor() {
	m.cleareddepartment_has_doctor = true
}

// DepartmentHasDoctorCleared reports if the "department_has_doctor" edge to the User entity was cleared.
func (m *DepartmentMutation) DepartmentHasDoctorCleared() bool {
	return m.cleareddepartment_has_doctor
}

// RemoveDepartmentHasDoctorIDs removes the "department_has_doctor" edge to the User entity by IDs.
func (m *DepartmentMutation) RemoveDepartmentHasDoctorIDs(ids ...int) {
	if m.removeddepartment_has_doctor == nil {
		m.removeddepartment_has_doctor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_has_doctor, ids[i])
		m.removeddepartment_has_doctor[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentHasDoctor returns the removed IDs of the "department_has_doctor" edge to the User entity.
func (m *DepartmentMutation) RemovedDepartmentHasDoctorIDs() (ids []int) {
	for id := range m.removeddepartment_has_doctor {
		ids = append(ids, id)
	}
	return
}

// DepartmentHasDoctorIDs returns the "department_has_doctor" edge IDs in the mutation.
func (m *DepartmentMutation) DepartmentHasDoctorIDs() (ids []int) {
	for id := range m.department_has_doctor {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentHasDoctor resets all changes to the "department_has_doctor" edge.
func (m *DepartmentMutation) ResetDepartmentHasDoctor() {
	m.department_has_doctor = nil
	m.cleareddepartment_has_doctor = false
	m.removeddepartment_has_doctor = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.image != nil {
		fields = append(fields, department.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.department_has_doctor != nil {
		edges = append(edges, department.EdgeDepartmentHasDoctor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentHasDoctor:
		ids := make([]ent.Value, 0, len(m.department_has_doctor))
		for id := range m.department_has_doctor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddepartment_has_doctor != nil {
		edges = append(edges, department.EdgeDepartmentHasDoctor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentHasDoctor:
		ids := make([]ent.Value, 0, len(m.removeddepartment_has_doctor))
		for id := range m.removeddepartment_has_doctor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddepartment_has_doctor {
		edges = append(edges, department.EdgeDepartmentHasDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeDepartmentHasDoctor:
		return m.cleareddepartment_has_doctor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDepartmentHasDoctor:
		m.ResetDepartmentHasDoctor()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DiseaseMutation represents an operation that mutates the Disease nodes in the graph.
type DiseaseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	symtoms             *string
	clearedFields       map[string]struct{}
	disease_user        map[int]struct{}
	removeddisease_user map[int]struct{}
	cleareddisease_user bool
	done                bool
	oldValue            func(context.Context) (*Disease, error)
	predicates          []predicate.Disease
}

var _ ent.Mutation = (*DiseaseMutation)(nil)

// diseaseOption allows management of the mutation configuration using functional options.
type diseaseOption func(*DiseaseMutation)

// newDiseaseMutation creates new mutation for the Disease entity.
func newDiseaseMutation(c config, op Op, opts ...diseaseOption) *DiseaseMutation {
	m := &DiseaseMutation{
		config:        c,
		op:            op,
		typ:           TypeDisease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiseaseID sets the ID field of the mutation.
func withDiseaseID(id int) diseaseOption {
	return func(m *DiseaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Disease
		)
		m.oldValue = func(ctx context.Context) (*Disease, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisease sets the old Disease of the mutation.
func withDisease(node *Disease) diseaseOption {
	return func(m *DiseaseMutation) {
		m.oldValue = func(context.Context) (*Disease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiseaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiseaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiseaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiseaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disease.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DiseaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DiseaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Disease entity.
// If the Disease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiseaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DiseaseMutation) ResetName() {
	m.name = nil
}

// SetSymtoms sets the "symtoms" field.
func (m *DiseaseMutation) SetSymtoms(s string) {
	m.symtoms = &s
}

// Symtoms returns the value of the "symtoms" field in the mutation.
func (m *DiseaseMutation) Symtoms() (r string, exists bool) {
	v := m.symtoms
	if v == nil {
		return
	}
	return *v, true
}

// OldSymtoms returns the old "symtoms" field's value of the Disease entity.
// If the Disease object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiseaseMutation) OldSymtoms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymtoms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymtoms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymtoms: %w", err)
	}
	return oldValue.Symtoms, nil
}

// ResetSymtoms resets all changes to the "symtoms" field.
func (m *DiseaseMutation) ResetSymtoms() {
	m.symtoms = nil
}

// AddDiseaseUserIDs adds the "disease_user" edge to the User entity by ids.
func (m *DiseaseMutation) AddDiseaseUserIDs(ids ...int) {
	if m.disease_user == nil {
		m.disease_user = make(map[int]struct{})
	}
	for i := range ids {
		m.disease_user[ids[i]] = struct{}{}
	}
}

// ClearDiseaseUser clears the "disease_user" edge to the User entity.
func (m *DiseaseMutation) ClearDiseaseUser() {
	m.cleareddisease_user = true
}

// DiseaseUserCleared reports if the "disease_user" edge to the User entity was cleared.
func (m *DiseaseMutation) DiseaseUserCleared() bool {
	return m.cleareddisease_user
}

// RemoveDiseaseUserIDs removes the "disease_user" edge to the User entity by IDs.
func (m *DiseaseMutation) RemoveDiseaseUserIDs(ids ...int) {
	if m.removeddisease_user == nil {
		m.removeddisease_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.disease_user, ids[i])
		m.removeddisease_user[ids[i]] = struct{}{}
	}
}

// RemovedDiseaseUser returns the removed IDs of the "disease_user" edge to the User entity.
func (m *DiseaseMutation) RemovedDiseaseUserIDs() (ids []int) {
	for id := range m.removeddisease_user {
		ids = append(ids, id)
	}
	return
}

// DiseaseUserIDs returns the "disease_user" edge IDs in the mutation.
func (m *DiseaseMutation) DiseaseUserIDs() (ids []int) {
	for id := range m.disease_user {
		ids = append(ids, id)
	}
	return
}

// ResetDiseaseUser resets all changes to the "disease_user" edge.
func (m *DiseaseMutation) ResetDiseaseUser() {
	m.disease_user = nil
	m.cleareddisease_user = false
	m.removeddisease_user = nil
}

// Where appends a list predicates to the DiseaseMutation builder.
func (m *DiseaseMutation) Where(ps ...predicate.Disease) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DiseaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disease).
func (m *DiseaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiseaseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, disease.FieldName)
	}
	if m.symtoms != nil {
		fields = append(fields, disease.FieldSymtoms)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiseaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disease.FieldName:
		return m.Name()
	case disease.FieldSymtoms:
		return m.Symtoms()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiseaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disease.FieldName:
		return m.OldName(ctx)
	case disease.FieldSymtoms:
		return m.OldSymtoms(ctx)
	}
	return nil, fmt.Errorf("unknown Disease field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiseaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disease.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case disease.FieldSymtoms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymtoms(v)
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiseaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiseaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiseaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiseaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiseaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiseaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disease nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiseaseMutation) ResetField(name string) error {
	switch name {
	case disease.FieldName:
		m.ResetName()
		return nil
	case disease.FieldSymtoms:
		m.ResetSymtoms()
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiseaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.disease_user != nil {
		edges = append(edges, disease.EdgeDiseaseUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiseaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDiseaseUser:
		ids := make([]ent.Value, 0, len(m.disease_user))
		for id := range m.disease_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiseaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddisease_user != nil {
		edges = append(edges, disease.EdgeDiseaseUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiseaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDiseaseUser:
		ids := make([]ent.Value, 0, len(m.removeddisease_user))
		for id := range m.removeddisease_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiseaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddisease_user {
		edges = append(edges, disease.EdgeDiseaseUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiseaseMutation) EdgeCleared(name string) bool {
	switch name {
	case disease.EdgeDiseaseUser:
		return m.cleareddisease_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiseaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiseaseMutation) ResetEdge(name string) error {
	switch name {
	case disease.EdgeDiseaseUser:
		m.ResetDiseaseUser()
		return nil
	}
	return fmt.Errorf("unknown Disease edge %s", name)
}

// HospitalMutation represents an operation that mutates the Hospital nodes in the graph.
type HospitalMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	clearedFields              map[string]struct{}
	hospital_has_doctor        map[int]struct{}
	removedhospital_has_doctor map[int]struct{}
	clearedhospital_has_doctor bool
	done                       bool
	oldValue                   func(context.Context) (*Hospital, error)
	predicates                 []predicate.Hospital
}

var _ ent.Mutation = (*HospitalMutation)(nil)

// hospitalOption allows management of the mutation configuration using functional options.
type hospitalOption func(*HospitalMutation)

// newHospitalMutation creates new mutation for the Hospital entity.
func newHospitalMutation(c config, op Op, opts ...hospitalOption) *HospitalMutation {
	m := &HospitalMutation{
		config:        c,
		op:            op,
		typ:           TypeHospital,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHospitalID sets the ID field of the mutation.
func withHospitalID(id int) hospitalOption {
	return func(m *HospitalMutation) {
		var (
			err   error
			once  sync.Once
			value *Hospital
		)
		m.oldValue = func(ctx context.Context) (*Hospital, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hospital.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHospital sets the old Hospital of the mutation.
func withHospital(node *Hospital) hospitalOption {
	return func(m *HospitalMutation) {
		m.oldValue = func(context.Context) (*Hospital, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HospitalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HospitalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HospitalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HospitalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hospital.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HospitalMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HospitalMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Hospital entity.
// If the Hospital object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HospitalMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HospitalMutation) ResetName() {
	m.name = nil
}

// AddHospitalHasDoctorIDs adds the "hospital_has_doctor" edge to the User entity by ids.
func (m *HospitalMutation) AddHospitalHasDoctorIDs(ids ...int) {
	if m.hospital_has_doctor == nil {
		m.hospital_has_doctor = make(map[int]struct{})
	}
	for i := range ids {
		m.hospital_has_doctor[ids[i]] = struct{}{}
	}
}

// ClearHospitalHasDoctor clears the "hospital_has_doctor" edge to the User entity.
func (m *HospitalMutation) ClearHospitalHasDoctor() {
	m.clearedhospital_has_doctor = true
}

// HospitalHasDoctorCleared reports if the "hospital_has_doctor" edge to the User entity was cleared.
func (m *HospitalMutation) HospitalHasDoctorCleared() bool {
	return m.clearedhospital_has_doctor
}

// RemoveHospitalHasDoctorIDs removes the "hospital_has_doctor" edge to the User entity by IDs.
func (m *HospitalMutation) RemoveHospitalHasDoctorIDs(ids ...int) {
	if m.removedhospital_has_doctor == nil {
		m.removedhospital_has_doctor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hospital_has_doctor, ids[i])
		m.removedhospital_has_doctor[ids[i]] = struct{}{}
	}
}

// RemovedHospitalHasDoctor returns the removed IDs of the "hospital_has_doctor" edge to the User entity.
func (m *HospitalMutation) RemovedHospitalHasDoctorIDs() (ids []int) {
	for id := range m.removedhospital_has_doctor {
		ids = append(ids, id)
	}
	return
}

// HospitalHasDoctorIDs returns the "hospital_has_doctor" edge IDs in the mutation.
func (m *HospitalMutation) HospitalHasDoctorIDs() (ids []int) {
	for id := range m.hospital_has_doctor {
		ids = append(ids, id)
	}
	return
}

// ResetHospitalHasDoctor resets all changes to the "hospital_has_doctor" edge.
func (m *HospitalMutation) ResetHospitalHasDoctor() {
	m.hospital_has_doctor = nil
	m.clearedhospital_has_doctor = false
	m.removedhospital_has_doctor = nil
}

// Where appends a list predicates to the HospitalMutation builder.
func (m *HospitalMutation) Where(ps ...predicate.Hospital) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HospitalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hospital).
func (m *HospitalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HospitalMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, hospital.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HospitalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hospital.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HospitalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hospital.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Hospital field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HospitalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hospital.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HospitalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HospitalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HospitalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HospitalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HospitalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HospitalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hospital nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HospitalMutation) ResetField(name string) error {
	switch name {
	case hospital.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Hospital field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HospitalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hospital_has_doctor != nil {
		edges = append(edges, hospital.EdgeHospitalHasDoctor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HospitalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospitalHasDoctor:
		ids := make([]ent.Value, 0, len(m.hospital_has_doctor))
		for id := range m.hospital_has_doctor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HospitalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhospital_has_doctor != nil {
		edges = append(edges, hospital.EdgeHospitalHasDoctor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HospitalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hospital.EdgeHospitalHasDoctor:
		ids := make([]ent.Value, 0, len(m.removedhospital_has_doctor))
		for id := range m.removedhospital_has_doctor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HospitalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhospital_has_doctor {
		edges = append(edges, hospital.EdgeHospitalHasDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HospitalMutation) EdgeCleared(name string) bool {
	switch name {
	case hospital.EdgeHospitalHasDoctor:
		return m.clearedhospital_has_doctor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HospitalMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Hospital unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HospitalMutation) ResetEdge(name string) error {
	switch name {
	case hospital.EdgeHospitalHasDoctor:
		m.ResetHospitalHasDoctor()
		return nil
	}
	return fmt.Errorf("unknown Hospital edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	message_text                           *string
	sent_dateTime                          *time.Time
	clearedFields                          map[string]struct{}
	_What_messages_are_in_this_chat        *int
	cleared_What_messages_are_in_this_chat bool
	_Who_send_messages                     *int
	cleared_Who_send_messages              bool
	done                                   bool
	oldValue                               func(context.Context) (*Message, error)
	predicates                             []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessageText sets the "message_text" field.
func (m *MessageMutation) SetMessageText(s string) {
	m.message_text = &s
}

// MessageText returns the value of the "message_text" field in the mutation.
func (m *MessageMutation) MessageText() (r string, exists bool) {
	v := m.message_text
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageText returns the old "message_text" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMessageText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageText: %w", err)
	}
	return oldValue.MessageText, nil
}

// ResetMessageText resets all changes to the "message_text" field.
func (m *MessageMutation) ResetMessageText() {
	m.message_text = nil
}

// SetSentDateTime sets the "sent_dateTime" field.
func (m *MessageMutation) SetSentDateTime(t time.Time) {
	m.sent_dateTime = &t
}

// SentDateTime returns the value of the "sent_dateTime" field in the mutation.
func (m *MessageMutation) SentDateTime() (r time.Time, exists bool) {
	v := m.sent_dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldSentDateTime returns the old "sent_dateTime" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSentDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentDateTime: %w", err)
	}
	return oldValue.SentDateTime, nil
}

// ClearSentDateTime clears the value of the "sent_dateTime" field.
func (m *MessageMutation) ClearSentDateTime() {
	m.sent_dateTime = nil
	m.clearedFields[message.FieldSentDateTime] = struct{}{}
}

// SentDateTimeCleared returns if the "sent_dateTime" field was cleared in this mutation.
func (m *MessageMutation) SentDateTimeCleared() bool {
	_, ok := m.clearedFields[message.FieldSentDateTime]
	return ok
}

// ResetSentDateTime resets all changes to the "sent_dateTime" field.
func (m *MessageMutation) ResetSentDateTime() {
	m.sent_dateTime = nil
	delete(m.clearedFields, message.FieldSentDateTime)
}

// SetWhatMessagesAreInThisChatID sets the "What_messages_are_in_this_chat" edge to the Chat entity by id.
func (m *MessageMutation) SetWhatMessagesAreInThisChatID(id int) {
	m._What_messages_are_in_this_chat = &id
}

// ClearWhatMessagesAreInThisChat clears the "What_messages_are_in_this_chat" edge to the Chat entity.
func (m *MessageMutation) ClearWhatMessagesAreInThisChat() {
	m.cleared_What_messages_are_in_this_chat = true
}

// WhatMessagesAreInThisChatCleared reports if the "What_messages_are_in_this_chat" edge to the Chat entity was cleared.
func (m *MessageMutation) WhatMessagesAreInThisChatCleared() bool {
	return m.cleared_What_messages_are_in_this_chat
}

// WhatMessagesAreInThisChatID returns the "What_messages_are_in_this_chat" edge ID in the mutation.
func (m *MessageMutation) WhatMessagesAreInThisChatID() (id int, exists bool) {
	if m._What_messages_are_in_this_chat != nil {
		return *m._What_messages_are_in_this_chat, true
	}
	return
}

// WhatMessagesAreInThisChatIDs returns the "What_messages_are_in_this_chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WhatMessagesAreInThisChatID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) WhatMessagesAreInThisChatIDs() (ids []int) {
	if id := m._What_messages_are_in_this_chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWhatMessagesAreInThisChat resets all changes to the "What_messages_are_in_this_chat" edge.
func (m *MessageMutation) ResetWhatMessagesAreInThisChat() {
	m._What_messages_are_in_this_chat = nil
	m.cleared_What_messages_are_in_this_chat = false
}

// SetWhoSendMessagesID sets the "Who_send_messages" edge to the User entity by id.
func (m *MessageMutation) SetWhoSendMessagesID(id int) {
	m._Who_send_messages = &id
}

// ClearWhoSendMessages clears the "Who_send_messages" edge to the User entity.
func (m *MessageMutation) ClearWhoSendMessages() {
	m.cleared_Who_send_messages = true
}

// WhoSendMessagesCleared reports if the "Who_send_messages" edge to the User entity was cleared.
func (m *MessageMutation) WhoSendMessagesCleared() bool {
	return m.cleared_Who_send_messages
}

// WhoSendMessagesID returns the "Who_send_messages" edge ID in the mutation.
func (m *MessageMutation) WhoSendMessagesID() (id int, exists bool) {
	if m._Who_send_messages != nil {
		return *m._Who_send_messages, true
	}
	return
}

// WhoSendMessagesIDs returns the "Who_send_messages" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WhoSendMessagesID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) WhoSendMessagesIDs() (ids []int) {
	if id := m._Who_send_messages; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWhoSendMessages resets all changes to the "Who_send_messages" edge.
func (m *MessageMutation) ResetWhoSendMessages() {
	m._Who_send_messages = nil
	m.cleared_Who_send_messages = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.message_text != nil {
		fields = append(fields, message.FieldMessageText)
	}
	if m.sent_dateTime != nil {
		fields = append(fields, message.FieldSentDateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldMessageText:
		return m.MessageText()
	case message.FieldSentDateTime:
		return m.SentDateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldMessageText:
		return m.OldMessageText(ctx)
	case message.FieldSentDateTime:
		return m.OldSentDateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldMessageText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageText(v)
		return nil
	case message.FieldSentDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentDateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldSentDateTime) {
		fields = append(fields, message.FieldSentDateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldSentDateTime:
		m.ClearSentDateTime()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldMessageText:
		m.ResetMessageText()
		return nil
	case message.FieldSentDateTime:
		m.ResetSentDateTime()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._What_messages_are_in_this_chat != nil {
		edges = append(edges, message.EdgeWhatMessagesAreInThisChat)
	}
	if m._Who_send_messages != nil {
		edges = append(edges, message.EdgeWhoSendMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeWhatMessagesAreInThisChat:
		if id := m._What_messages_are_in_this_chat; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeWhoSendMessages:
		if id := m._Who_send_messages; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_What_messages_are_in_this_chat {
		edges = append(edges, message.EdgeWhatMessagesAreInThisChat)
	}
	if m.cleared_Who_send_messages {
		edges = append(edges, message.EdgeWhoSendMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeWhatMessagesAreInThisChat:
		return m.cleared_What_messages_are_in_this_chat
	case message.EdgeWhoSendMessages:
		return m.cleared_Who_send_messages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeWhatMessagesAreInThisChat:
		m.ClearWhatMessagesAreInThisChat()
		return nil
	case message.EdgeWhoSendMessages:
		m.ClearWhoSendMessages()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeWhatMessagesAreInThisChat:
		m.ResetWhatMessagesAreInThisChat()
		return nil
	case message.EdgeWhoSendMessages:
		m.ResetWhoSendMessages()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Message                 *string
	_CreatedDate             *time.Time
	_RecipientId             *int
	add_RecipientId          *int
	_SenderId                *int
	add_SenderId             *int
	_AppointmentId           *int
	add_AppointmentId        *int
	clearedFields            map[string]struct{}
	user_notification        map[int]struct{}
	removeduser_notification map[int]struct{}
	cleareduser_notification bool
	done                     bool
	oldValue                 func(context.Context) (*Notification, error)
	predicates               []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMessage sets the "Message" field.
func (m *NotificationMutation) SetMessage(s string) {
	m._Message = &s
}

// Message returns the value of the "Message" field in the mutation.
func (m *NotificationMutation) Message() (r string, exists bool) {
	v := m._Message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "Message" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "Message" field.
func (m *NotificationMutation) ResetMessage() {
	m._Message = nil
}

// SetCreatedDate sets the "CreatedDate" field.
func (m *NotificationMutation) SetCreatedDate(t time.Time) {
	m._CreatedDate = &t
}

// CreatedDate returns the value of the "CreatedDate" field in the mutation.
func (m *NotificationMutation) CreatedDate() (r time.Time, exists bool) {
	v := m._CreatedDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "CreatedDate" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "CreatedDate" field.
func (m *NotificationMutation) ClearCreatedDate() {
	m._CreatedDate = nil
	m.clearedFields[notification.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "CreatedDate" field was cleared in this mutation.
func (m *NotificationMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[notification.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "CreatedDate" field.
func (m *NotificationMutation) ResetCreatedDate() {
	m._CreatedDate = nil
	delete(m.clearedFields, notification.FieldCreatedDate)
}

// SetRecipientId sets the "RecipientId" field.
func (m *NotificationMutation) SetRecipientId(i int) {
	m._RecipientId = &i
	m.add_RecipientId = nil
}

// RecipientId returns the value of the "RecipientId" field in the mutation.
func (m *NotificationMutation) RecipientId() (r int, exists bool) {
	v := m._RecipientId
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientId returns the old "RecipientId" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRecipientId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientId: %w", err)
	}
	return oldValue.RecipientId, nil
}

// AddRecipientId adds i to the "RecipientId" field.
func (m *NotificationMutation) AddRecipientId(i int) {
	if m.add_RecipientId != nil {
		*m.add_RecipientId += i
	} else {
		m.add_RecipientId = &i
	}
}

// AddedRecipientId returns the value that was added to the "RecipientId" field in this mutation.
func (m *NotificationMutation) AddedRecipientId() (r int, exists bool) {
	v := m.add_RecipientId
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecipientId resets all changes to the "RecipientId" field.
func (m *NotificationMutation) ResetRecipientId() {
	m._RecipientId = nil
	m.add_RecipientId = nil
}

// SetSenderId sets the "SenderId" field.
func (m *NotificationMutation) SetSenderId(i int) {
	m._SenderId = &i
	m.add_SenderId = nil
}

// SenderId returns the value of the "SenderId" field in the mutation.
func (m *NotificationMutation) SenderId() (r int, exists bool) {
	v := m._SenderId
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderId returns the old "SenderId" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSenderId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderId: %w", err)
	}
	return oldValue.SenderId, nil
}

// AddSenderId adds i to the "SenderId" field.
func (m *NotificationMutation) AddSenderId(i int) {
	if m.add_SenderId != nil {
		*m.add_SenderId += i
	} else {
		m.add_SenderId = &i
	}
}

// AddedSenderId returns the value that was added to the "SenderId" field in this mutation.
func (m *NotificationMutation) AddedSenderId() (r int, exists bool) {
	v := m.add_SenderId
	if v == nil {
		return
	}
	return *v, true
}

// ResetSenderId resets all changes to the "SenderId" field.
func (m *NotificationMutation) ResetSenderId() {
	m._SenderId = nil
	m.add_SenderId = nil
}

// SetAppointmentId sets the "AppointmentId" field.
func (m *NotificationMutation) SetAppointmentId(i int) {
	m._AppointmentId = &i
	m.add_AppointmentId = nil
}

// AppointmentId returns the value of the "AppointmentId" field in the mutation.
func (m *NotificationMutation) AppointmentId() (r int, exists bool) {
	v := m._AppointmentId
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentId returns the old "AppointmentId" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldAppointmentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentId: %w", err)
	}
	return oldValue.AppointmentId, nil
}

// AddAppointmentId adds i to the "AppointmentId" field.
func (m *NotificationMutation) AddAppointmentId(i int) {
	if m.add_AppointmentId != nil {
		*m.add_AppointmentId += i
	} else {
		m.add_AppointmentId = &i
	}
}

// AddedAppointmentId returns the value that was added to the "AppointmentId" field in this mutation.
func (m *NotificationMutation) AddedAppointmentId() (r int, exists bool) {
	v := m.add_AppointmentId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppointmentId resets all changes to the "AppointmentId" field.
func (m *NotificationMutation) ResetAppointmentId() {
	m._AppointmentId = nil
	m.add_AppointmentId = nil
}

// AddUserNotificationIDs adds the "user_notification" edge to the User entity by ids.
func (m *NotificationMutation) AddUserNotificationIDs(ids ...int) {
	if m.user_notification == nil {
		m.user_notification = make(map[int]struct{})
	}
	for i := range ids {
		m.user_notification[ids[i]] = struct{}{}
	}
}

// ClearUserNotification clears the "user_notification" edge to the User entity.
func (m *NotificationMutation) ClearUserNotification() {
	m.cleareduser_notification = true
}

// UserNotificationCleared reports if the "user_notification" edge to the User entity was cleared.
func (m *NotificationMutation) UserNotificationCleared() bool {
	return m.cleareduser_notification
}

// RemoveUserNotificationIDs removes the "user_notification" edge to the User entity by IDs.
func (m *NotificationMutation) RemoveUserNotificationIDs(ids ...int) {
	if m.removeduser_notification == nil {
		m.removeduser_notification = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_notification, ids[i])
		m.removeduser_notification[ids[i]] = struct{}{}
	}
}

// RemovedUserNotification returns the removed IDs of the "user_notification" edge to the User entity.
func (m *NotificationMutation) RemovedUserNotificationIDs() (ids []int) {
	for id := range m.removeduser_notification {
		ids = append(ids, id)
	}
	return
}

// UserNotificationIDs returns the "user_notification" edge IDs in the mutation.
func (m *NotificationMutation) UserNotificationIDs() (ids []int) {
	for id := range m.user_notification {
		ids = append(ids, id)
	}
	return
}

// ResetUserNotification resets all changes to the "user_notification" edge.
func (m *NotificationMutation) ResetUserNotification() {
	m.user_notification = nil
	m.cleareduser_notification = false
	m.removeduser_notification = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._Message != nil {
		fields = append(fields, notification.FieldMessage)
	}
	if m._CreatedDate != nil {
		fields = append(fields, notification.FieldCreatedDate)
	}
	if m._RecipientId != nil {
		fields = append(fields, notification.FieldRecipientId)
	}
	if m._SenderId != nil {
		fields = append(fields, notification.FieldSenderId)
	}
	if m._AppointmentId != nil {
		fields = append(fields, notification.FieldAppointmentId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldMessage:
		return m.Message()
	case notification.FieldCreatedDate:
		return m.CreatedDate()
	case notification.FieldRecipientId:
		return m.RecipientId()
	case notification.FieldSenderId:
		return m.SenderId()
	case notification.FieldAppointmentId:
		return m.AppointmentId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldMessage:
		return m.OldMessage(ctx)
	case notification.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case notification.FieldRecipientId:
		return m.OldRecipientId(ctx)
	case notification.FieldSenderId:
		return m.OldSenderId(ctx)
	case notification.FieldAppointmentId:
		return m.OldAppointmentId(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case notification.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case notification.FieldRecipientId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientId(v)
		return nil
	case notification.FieldSenderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderId(v)
		return nil
	case notification.FieldAppointmentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentId(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.add_RecipientId != nil {
		fields = append(fields, notification.FieldRecipientId)
	}
	if m.add_SenderId != nil {
		fields = append(fields, notification.FieldSenderId)
	}
	if m.add_AppointmentId != nil {
		fields = append(fields, notification.FieldAppointmentId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldRecipientId:
		return m.AddedRecipientId()
	case notification.FieldSenderId:
		return m.AddedSenderId()
	case notification.FieldAppointmentId:
		return m.AddedAppointmentId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldRecipientId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecipientId(v)
		return nil
	case notification.FieldSenderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSenderId(v)
		return nil
	case notification.FieldAppointmentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppointmentId(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldCreatedDate) {
		fields = append(fields, notification.FieldCreatedDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldMessage:
		m.ResetMessage()
		return nil
	case notification.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case notification.FieldRecipientId:
		m.ResetRecipientId()
		return nil
	case notification.FieldSenderId:
		m.ResetSenderId()
		return nil
	case notification.FieldAppointmentId:
		m.ResetAppointmentId()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_notification != nil {
		edges = append(edges, notification.EdgeUserNotification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeUserNotification:
		ids := make([]ent.Value, 0, len(m.user_notification))
		for id := range m.user_notification {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_notification != nil {
		edges = append(edges, notification.EdgeUserNotification)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeUserNotification:
		ids := make([]ent.Value, 0, len(m.removeduser_notification))
		for id := range m.removeduser_notification {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_notification {
		edges = append(edges, notification.EdgeUserNotification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeUserNotification:
		return m.cleareduser_notification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeUserNotification:
		m.ResetUserNotification()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PInfoMutation represents an operation that mutates the PInfo nodes in the graph.
type PInfoMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int
	profile                               *string
	idCardNumber                          *string
	prefix                                *string
	firstName                             *string
	lastName                              *string
	gender                                *int
	addgender                             *int
	brithDate                             *time.Time
	bloodGroup                            *string
	address                               *string
	about                                 *string
	clearedFields                         map[string]struct{}
	who_is_the_owner_of_this_PInfo        *int
	clearedwho_is_the_owner_of_this_PInfo bool
	done                                  bool
	oldValue                              func(context.Context) (*PInfo, error)
	predicates                            []predicate.PInfo
}

var _ ent.Mutation = (*PInfoMutation)(nil)

// pinfoOption allows management of the mutation configuration using functional options.
type pinfoOption func(*PInfoMutation)

// newPInfoMutation creates new mutation for the PInfo entity.
func newPInfoMutation(c config, op Op, opts ...pinfoOption) *PInfoMutation {
	m := &PInfoMutation{
		config:        c,
		op:            op,
		typ:           TypePInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPInfoID sets the ID field of the mutation.
func withPInfoID(id int) pinfoOption {
	return func(m *PInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *PInfo
		)
		m.oldValue = func(ctx context.Context) (*PInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPInfo sets the old PInfo of the mutation.
func withPInfo(node *PInfo) pinfoOption {
	return func(m *PInfoMutation) {
		m.oldValue = func(context.Context) (*PInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProfile sets the "profile" field.
func (m *PInfoMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *PInfoMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ResetProfile resets all changes to the "profile" field.
func (m *PInfoMutation) ResetProfile() {
	m.profile = nil
}

// SetIdCardNumber sets the "idCardNumber" field.
func (m *PInfoMutation) SetIdCardNumber(s string) {
	m.idCardNumber = &s
}

// IdCardNumber returns the value of the "idCardNumber" field in the mutation.
func (m *PInfoMutation) IdCardNumber() (r string, exists bool) {
	v := m.idCardNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldIdCardNumber returns the old "idCardNumber" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldIdCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdCardNumber: %w", err)
	}
	return oldValue.IdCardNumber, nil
}

// ResetIdCardNumber resets all changes to the "idCardNumber" field.
func (m *PInfoMutation) ResetIdCardNumber() {
	m.idCardNumber = nil
}

// SetPrefix sets the "prefix" field.
func (m *PInfoMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *PInfoMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *PInfoMutation) ResetPrefix() {
	m.prefix = nil
}

// SetFirstName sets the "firstName" field.
func (m *PInfoMutation) SetFirstName(s string) {
	m.firstName = &s
}

// FirstName returns the value of the "firstName" field in the mutation.
func (m *PInfoMutation) FirstName() (r string, exists bool) {
	v := m.firstName
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "firstName" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "firstName" field.
func (m *PInfoMutation) ResetFirstName() {
	m.firstName = nil
}

// SetLastName sets the "lastName" field.
func (m *PInfoMutation) SetLastName(s string) {
	m.lastName = &s
}

// LastName returns the value of the "lastName" field in the mutation.
func (m *PInfoMutation) LastName() (r string, exists bool) {
	v := m.lastName
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "lastName" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "lastName" field.
func (m *PInfoMutation) ResetLastName() {
	m.lastName = nil
}

// SetGender sets the "gender" field.
func (m *PInfoMutation) SetGender(i int) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PInfoMutation) Gender() (r int, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldGender(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *PInfoMutation) AddGender(i int) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *PInfoMutation) AddedGender() (r int, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *PInfoMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetBrithDate sets the "brithDate" field.
func (m *PInfoMutation) SetBrithDate(t time.Time) {
	m.brithDate = &t
}

// BrithDate returns the value of the "brithDate" field in the mutation.
func (m *PInfoMutation) BrithDate() (r time.Time, exists bool) {
	v := m.brithDate
	if v == nil {
		return
	}
	return *v, true
}

// OldBrithDate returns the old "brithDate" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldBrithDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrithDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrithDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrithDate: %w", err)
	}
	return oldValue.BrithDate, nil
}

// ClearBrithDate clears the value of the "brithDate" field.
func (m *PInfoMutation) ClearBrithDate() {
	m.brithDate = nil
	m.clearedFields[pinfo.FieldBrithDate] = struct{}{}
}

// BrithDateCleared returns if the "brithDate" field was cleared in this mutation.
func (m *PInfoMutation) BrithDateCleared() bool {
	_, ok := m.clearedFields[pinfo.FieldBrithDate]
	return ok
}

// ResetBrithDate resets all changes to the "brithDate" field.
func (m *PInfoMutation) ResetBrithDate() {
	m.brithDate = nil
	delete(m.clearedFields, pinfo.FieldBrithDate)
}

// SetBloodGroup sets the "bloodGroup" field.
func (m *PInfoMutation) SetBloodGroup(s string) {
	m.bloodGroup = &s
}

// BloodGroup returns the value of the "bloodGroup" field in the mutation.
func (m *PInfoMutation) BloodGroup() (r string, exists bool) {
	v := m.bloodGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldBloodGroup returns the old "bloodGroup" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldBloodGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBloodGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBloodGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBloodGroup: %w", err)
	}
	return oldValue.BloodGroup, nil
}

// ResetBloodGroup resets all changes to the "bloodGroup" field.
func (m *PInfoMutation) ResetBloodGroup() {
	m.bloodGroup = nil
}

// SetAddress sets the "address" field.
func (m *PInfoMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PInfoMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PInfoMutation) ResetAddress() {
	m.address = nil
}

// SetAbout sets the "about" field.
func (m *PInfoMutation) SetAbout(s string) {
	m.about = &s
}

// About returns the value of the "about" field in the mutation.
func (m *PInfoMutation) About() (r string, exists bool) {
	v := m.about
	if v == nil {
		return
	}
	return *v, true
}

// OldAbout returns the old "about" field's value of the PInfo entity.
// If the PInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PInfoMutation) OldAbout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbout: %w", err)
	}
	return oldValue.About, nil
}

// ResetAbout resets all changes to the "about" field.
func (m *PInfoMutation) ResetAbout() {
	m.about = nil
}

// SetWhoIsTheOwnerOfThisPInfoID sets the "who_is_the_owner_of_this_PInfo" edge to the User entity by id.
func (m *PInfoMutation) SetWhoIsTheOwnerOfThisPInfoID(id int) {
	m.who_is_the_owner_of_this_PInfo = &id
}

// ClearWhoIsTheOwnerOfThisPInfo clears the "who_is_the_owner_of_this_PInfo" edge to the User entity.
func (m *PInfoMutation) ClearWhoIsTheOwnerOfThisPInfo() {
	m.clearedwho_is_the_owner_of_this_PInfo = true
}

// WhoIsTheOwnerOfThisPInfoCleared reports if the "who_is_the_owner_of_this_PInfo" edge to the User entity was cleared.
func (m *PInfoMutation) WhoIsTheOwnerOfThisPInfoCleared() bool {
	return m.clearedwho_is_the_owner_of_this_PInfo
}

// WhoIsTheOwnerOfThisPInfoID returns the "who_is_the_owner_of_this_PInfo" edge ID in the mutation.
func (m *PInfoMutation) WhoIsTheOwnerOfThisPInfoID() (id int, exists bool) {
	if m.who_is_the_owner_of_this_PInfo != nil {
		return *m.who_is_the_owner_of_this_PInfo, true
	}
	return
}

// WhoIsTheOwnerOfThisPInfoIDs returns the "who_is_the_owner_of_this_PInfo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WhoIsTheOwnerOfThisPInfoID instead. It exists only for internal usage by the builders.
func (m *PInfoMutation) WhoIsTheOwnerOfThisPInfoIDs() (ids []int) {
	if id := m.who_is_the_owner_of_this_PInfo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWhoIsTheOwnerOfThisPInfo resets all changes to the "who_is_the_owner_of_this_PInfo" edge.
func (m *PInfoMutation) ResetWhoIsTheOwnerOfThisPInfo() {
	m.who_is_the_owner_of_this_PInfo = nil
	m.clearedwho_is_the_owner_of_this_PInfo = false
}

// Where appends a list predicates to the PInfoMutation builder.
func (m *PInfoMutation) Where(ps ...predicate.PInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PInfo).
func (m *PInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PInfoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.profile != nil {
		fields = append(fields, pinfo.FieldProfile)
	}
	if m.idCardNumber != nil {
		fields = append(fields, pinfo.FieldIdCardNumber)
	}
	if m.prefix != nil {
		fields = append(fields, pinfo.FieldPrefix)
	}
	if m.firstName != nil {
		fields = append(fields, pinfo.FieldFirstName)
	}
	if m.lastName != nil {
		fields = append(fields, pinfo.FieldLastName)
	}
	if m.gender != nil {
		fields = append(fields, pinfo.FieldGender)
	}
	if m.brithDate != nil {
		fields = append(fields, pinfo.FieldBrithDate)
	}
	if m.bloodGroup != nil {
		fields = append(fields, pinfo.FieldBloodGroup)
	}
	if m.address != nil {
		fields = append(fields, pinfo.FieldAddress)
	}
	if m.about != nil {
		fields = append(fields, pinfo.FieldAbout)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pinfo.FieldProfile:
		return m.Profile()
	case pinfo.FieldIdCardNumber:
		return m.IdCardNumber()
	case pinfo.FieldPrefix:
		return m.Prefix()
	case pinfo.FieldFirstName:
		return m.FirstName()
	case pinfo.FieldLastName:
		return m.LastName()
	case pinfo.FieldGender:
		return m.Gender()
	case pinfo.FieldBrithDate:
		return m.BrithDate()
	case pinfo.FieldBloodGroup:
		return m.BloodGroup()
	case pinfo.FieldAddress:
		return m.Address()
	case pinfo.FieldAbout:
		return m.About()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pinfo.FieldProfile:
		return m.OldProfile(ctx)
	case pinfo.FieldIdCardNumber:
		return m.OldIdCardNumber(ctx)
	case pinfo.FieldPrefix:
		return m.OldPrefix(ctx)
	case pinfo.FieldFirstName:
		return m.OldFirstName(ctx)
	case pinfo.FieldLastName:
		return m.OldLastName(ctx)
	case pinfo.FieldGender:
		return m.OldGender(ctx)
	case pinfo.FieldBrithDate:
		return m.OldBrithDate(ctx)
	case pinfo.FieldBloodGroup:
		return m.OldBloodGroup(ctx)
	case pinfo.FieldAddress:
		return m.OldAddress(ctx)
	case pinfo.FieldAbout:
		return m.OldAbout(ctx)
	}
	return nil, fmt.Errorf("unknown PInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pinfo.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case pinfo.FieldIdCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdCardNumber(v)
		return nil
	case pinfo.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case pinfo.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case pinfo.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case pinfo.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case pinfo.FieldBrithDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrithDate(v)
		return nil
	case pinfo.FieldBloodGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBloodGroup(v)
		return nil
	case pinfo.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case pinfo.FieldAbout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbout(v)
		return nil
	}
	return fmt.Errorf("unknown PInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PInfoMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, pinfo.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pinfo.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pinfo.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown PInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pinfo.FieldBrithDate) {
		fields = append(fields, pinfo.FieldBrithDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PInfoMutation) ClearField(name string) error {
	switch name {
	case pinfo.FieldBrithDate:
		m.ClearBrithDate()
		return nil
	}
	return fmt.Errorf("unknown PInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PInfoMutation) ResetField(name string) error {
	switch name {
	case pinfo.FieldProfile:
		m.ResetProfile()
		return nil
	case pinfo.FieldIdCardNumber:
		m.ResetIdCardNumber()
		return nil
	case pinfo.FieldPrefix:
		m.ResetPrefix()
		return nil
	case pinfo.FieldFirstName:
		m.ResetFirstName()
		return nil
	case pinfo.FieldLastName:
		m.ResetLastName()
		return nil
	case pinfo.FieldGender:
		m.ResetGender()
		return nil
	case pinfo.FieldBrithDate:
		m.ResetBrithDate()
		return nil
	case pinfo.FieldBloodGroup:
		m.ResetBloodGroup()
		return nil
	case pinfo.FieldAddress:
		m.ResetAddress()
		return nil
	case pinfo.FieldAbout:
		m.ResetAbout()
		return nil
	}
	return fmt.Errorf("unknown PInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.who_is_the_owner_of_this_PInfo != nil {
		edges = append(edges, pinfo.EdgeWhoIsTheOwnerOfThisPInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pinfo.EdgeWhoIsTheOwnerOfThisPInfo:
		if id := m.who_is_the_owner_of_this_PInfo; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwho_is_the_owner_of_this_PInfo {
		edges = append(edges, pinfo.EdgeWhoIsTheOwnerOfThisPInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case pinfo.EdgeWhoIsTheOwnerOfThisPInfo:
		return m.clearedwho_is_the_owner_of_this_PInfo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PInfoMutation) ClearEdge(name string) error {
	switch name {
	case pinfo.EdgeWhoIsTheOwnerOfThisPInfo:
		m.ClearWhoIsTheOwnerOfThisPInfo()
		return nil
	}
	return fmt.Errorf("unknown PInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PInfoMutation) ResetEdge(name string) error {
	switch name {
	case pinfo.EdgeWhoIsTheOwnerOfThisPInfo:
		m.ResetWhoIsTheOwnerOfThisPInfo()
		return nil
	}
	return fmt.Errorf("unknown PInfo edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	role_user        map[int]struct{}
	removedrole_user map[int]struct{}
	clearedrole_user bool
	done             bool
	oldValue         func(context.Context) (*Role, error)
	predicates       []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// AddRoleUserIDs adds the "role_user" edge to the User entity by ids.
func (m *RoleMutation) AddRoleUserIDs(ids ...int) {
	if m.role_user == nil {
		m.role_user = make(map[int]struct{})
	}
	for i := range ids {
		m.role_user[ids[i]] = struct{}{}
	}
}

// ClearRoleUser clears the "role_user" edge to the User entity.
func (m *RoleMutation) ClearRoleUser() {
	m.clearedrole_user = true
}

// RoleUserCleared reports if the "role_user" edge to the User entity was cleared.
func (m *RoleMutation) RoleUserCleared() bool {
	return m.clearedrole_user
}

// RemoveRoleUserIDs removes the "role_user" edge to the User entity by IDs.
func (m *RoleMutation) RemoveRoleUserIDs(ids ...int) {
	if m.removedrole_user == nil {
		m.removedrole_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_user, ids[i])
		m.removedrole_user[ids[i]] = struct{}{}
	}
}

// RemovedRoleUser returns the removed IDs of the "role_user" edge to the User entity.
func (m *RoleMutation) RemovedRoleUserIDs() (ids []int) {
	for id := range m.removedrole_user {
		ids = append(ids, id)
	}
	return
}

// RoleUserIDs returns the "role_user" edge IDs in the mutation.
func (m *RoleMutation) RoleUserIDs() (ids []int) {
	for id := range m.role_user {
		ids = append(ids, id)
	}
	return
}

// ResetRoleUser resets all changes to the "role_user" edge.
func (m *RoleMutation) ResetRoleUser() {
	m.role_user = nil
	m.clearedrole_user = false
	m.removedrole_user = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role_user != nil {
		edges = append(edges, role.EdgeRoleUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRoleUser:
		ids := make([]ent.Value, 0, len(m.role_user))
		for id := range m.role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrole_user != nil {
		edges = append(edges, role.EdgeRoleUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRoleUser:
		ids := make([]ent.Value, 0, len(m.removedrole_user))
		for id := range m.removedrole_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole_user {
		edges = append(edges, role.EdgeRoleUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeRoleUser:
		return m.clearedrole_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRoleUser:
		m.ResetRoleUser()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	activity                    *string
	detail                      *string
	status                      *string
	startTime                   *time.Time
	endTime                     *time.Time
	clearedFields               map[string]struct{}
	schedule_appointment        map[int]struct{}
	removedschedule_appointment map[int]struct{}
	clearedschedule_appointment bool
	schedule_doctor             *int
	clearedschedule_doctor      bool
	done                        bool
	oldValue                    func(context.Context) (*Schedule, error)
	predicates                  []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id int) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivity sets the "activity" field.
func (m *ScheduleMutation) SetActivity(s string) {
	m.activity = &s
}

// Activity returns the value of the "activity" field in the mutation.
func (m *ScheduleMutation) Activity() (r string, exists bool) {
	v := m.activity
	if v == nil {
		return
	}
	return *v, true
}

// OldActivity returns the old "activity" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldActivity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivity: %w", err)
	}
	return oldValue.Activity, nil
}

// ResetActivity resets all changes to the "activity" field.
func (m *ScheduleMutation) ResetActivity() {
	m.activity = nil
}

// SetDetail sets the "detail" field.
func (m *ScheduleMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ScheduleMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *ScheduleMutation) ResetDetail() {
	m.detail = nil
}

// SetStatus sets the "status" field.
func (m *ScheduleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ScheduleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScheduleMutation) ResetStatus() {
	m.status = nil
}

// SetStartTime sets the "startTime" field.
func (m *ScheduleMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *ScheduleMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "startTime" field.
func (m *ScheduleMutation) ClearStartTime() {
	m.startTime = nil
	m.clearedFields[schedule.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "startTime" field was cleared in this mutation.
func (m *ScheduleMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *ScheduleMutation) ResetStartTime() {
	m.startTime = nil
	delete(m.clearedFields, schedule.FieldStartTime)
}

// SetEndTime sets the "endTime" field.
func (m *ScheduleMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *ScheduleMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "endTime" field.
func (m *ScheduleMutation) ClearEndTime() {
	m.endTime = nil
	m.clearedFields[schedule.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "endTime" field was cleared in this mutation.
func (m *ScheduleMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schedule.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *ScheduleMutation) ResetEndTime() {
	m.endTime = nil
	delete(m.clearedFields, schedule.FieldEndTime)
}

// AddScheduleAppointmentIDs adds the "schedule_appointment" edge to the Appointment entity by ids.
func (m *ScheduleMutation) AddScheduleAppointmentIDs(ids ...int) {
	if m.schedule_appointment == nil {
		m.schedule_appointment = make(map[int]struct{})
	}
	for i := range ids {
		m.schedule_appointment[ids[i]] = struct{}{}
	}
}

// ClearScheduleAppointment clears the "schedule_appointment" edge to the Appointment entity.
func (m *ScheduleMutation) ClearScheduleAppointment() {
	m.clearedschedule_appointment = true
}

// ScheduleAppointmentCleared reports if the "schedule_appointment" edge to the Appointment entity was cleared.
func (m *ScheduleMutation) ScheduleAppointmentCleared() bool {
	return m.clearedschedule_appointment
}

// RemoveScheduleAppointmentIDs removes the "schedule_appointment" edge to the Appointment entity by IDs.
func (m *ScheduleMutation) RemoveScheduleAppointmentIDs(ids ...int) {
	if m.removedschedule_appointment == nil {
		m.removedschedule_appointment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.schedule_appointment, ids[i])
		m.removedschedule_appointment[ids[i]] = struct{}{}
	}
}

// RemovedScheduleAppointment returns the removed IDs of the "schedule_appointment" edge to the Appointment entity.
func (m *ScheduleMutation) RemovedScheduleAppointmentIDs() (ids []int) {
	for id := range m.removedschedule_appointment {
		ids = append(ids, id)
	}
	return
}

// ScheduleAppointmentIDs returns the "schedule_appointment" edge IDs in the mutation.
func (m *ScheduleMutation) ScheduleAppointmentIDs() (ids []int) {
	for id := range m.schedule_appointment {
		ids = append(ids, id)
	}
	return
}

// ResetScheduleAppointment resets all changes to the "schedule_appointment" edge.
func (m *ScheduleMutation) ResetScheduleAppointment() {
	m.schedule_appointment = nil
	m.clearedschedule_appointment = false
	m.removedschedule_appointment = nil
}

// SetScheduleDoctorID sets the "schedule_doctor" edge to the User entity by id.
func (m *ScheduleMutation) SetScheduleDoctorID(id int) {
	m.schedule_doctor = &id
}

// ClearScheduleDoctor clears the "schedule_doctor" edge to the User entity.
func (m *ScheduleMutation) ClearScheduleDoctor() {
	m.clearedschedule_doctor = true
}

// ScheduleDoctorCleared reports if the "schedule_doctor" edge to the User entity was cleared.
func (m *ScheduleMutation) ScheduleDoctorCleared() bool {
	return m.clearedschedule_doctor
}

// ScheduleDoctorID returns the "schedule_doctor" edge ID in the mutation.
func (m *ScheduleMutation) ScheduleDoctorID() (id int, exists bool) {
	if m.schedule_doctor != nil {
		return *m.schedule_doctor, true
	}
	return
}

// ScheduleDoctorIDs returns the "schedule_doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleDoctorID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) ScheduleDoctorIDs() (ids []int) {
	if id := m.schedule_doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScheduleDoctor resets all changes to the "schedule_doctor" edge.
func (m *ScheduleMutation) ResetScheduleDoctor() {
	m.schedule_doctor = nil
	m.clearedschedule_doctor = false
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.activity != nil {
		fields = append(fields, schedule.FieldActivity)
	}
	if m.detail != nil {
		fields = append(fields, schedule.FieldDetail)
	}
	if m.status != nil {
		fields = append(fields, schedule.FieldStatus)
	}
	if m.startTime != nil {
		fields = append(fields, schedule.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, schedule.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldActivity:
		return m.Activity()
	case schedule.FieldDetail:
		return m.Detail()
	case schedule.FieldStatus:
		return m.Status()
	case schedule.FieldStartTime:
		return m.StartTime()
	case schedule.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldActivity:
		return m.OldActivity(ctx)
	case schedule.FieldDetail:
		return m.OldDetail(ctx)
	case schedule.FieldStatus:
		return m.OldStatus(ctx)
	case schedule.FieldStartTime:
		return m.OldStartTime(ctx)
	case schedule.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldActivity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivity(v)
		return nil
	case schedule.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case schedule.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case schedule.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case schedule.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedule.FieldStartTime) {
		fields = append(fields, schedule.FieldStartTime)
	}
	if m.FieldCleared(schedule.FieldEndTime) {
		fields = append(fields, schedule.FieldEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	switch name {
	case schedule.FieldStartTime:
		m.ClearStartTime()
		return nil
	case schedule.FieldEndTime:
		m.ClearEndTime()
		return nil
	}
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldActivity:
		m.ResetActivity()
		return nil
	case schedule.FieldDetail:
		m.ResetDetail()
		return nil
	case schedule.FieldStatus:
		m.ResetStatus()
		return nil
	case schedule.FieldStartTime:
		m.ResetStartTime()
		return nil
	case schedule.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.schedule_appointment != nil {
		edges = append(edges, schedule.EdgeScheduleAppointment)
	}
	if m.schedule_doctor != nil {
		edges = append(edges, schedule.EdgeScheduleDoctor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeScheduleAppointment:
		ids := make([]ent.Value, 0, len(m.schedule_appointment))
		for id := range m.schedule_appointment {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeScheduleDoctor:
		if id := m.schedule_doctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedschedule_appointment != nil {
		edges = append(edges, schedule.EdgeScheduleAppointment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeScheduleAppointment:
		ids := make([]ent.Value, 0, len(m.removedschedule_appointment))
		for id := range m.removedschedule_appointment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedschedule_appointment {
		edges = append(edges, schedule.EdgeScheduleAppointment)
	}
	if m.clearedschedule_doctor {
		edges = append(edges, schedule.EdgeScheduleDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeScheduleAppointment:
		return m.clearedschedule_appointment
	case schedule.EdgeScheduleDoctor:
		return m.clearedschedule_doctor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	case schedule.EdgeScheduleDoctor:
		m.ClearScheduleDoctor()
		return nil
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeScheduleAppointment:
		m.ResetScheduleAppointment()
		return nil
	case schedule.EdgeScheduleDoctor:
		m.ResetScheduleDoctor()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// TelecomMutation represents an operation that mutates the Telecom nodes in the graph.
type TelecomMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	email                                   *string
	telephone                               *string
	username                                *string
	platform                                *string
	clearedFields                           map[string]struct{}
	who_is_the_owner_of_this_telecom        *int
	clearedwho_is_the_owner_of_this_telecom bool
	done                                    bool
	oldValue                                func(context.Context) (*Telecom, error)
	predicates                              []predicate.Telecom
}

var _ ent.Mutation = (*TelecomMutation)(nil)

// telecomOption allows management of the mutation configuration using functional options.
type telecomOption func(*TelecomMutation)

// newTelecomMutation creates new mutation for the Telecom entity.
func newTelecomMutation(c config, op Op, opts ...telecomOption) *TelecomMutation {
	m := &TelecomMutation{
		config:        c,
		op:            op,
		typ:           TypeTelecom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTelecomID sets the ID field of the mutation.
func withTelecomID(id int) telecomOption {
	return func(m *TelecomMutation) {
		var (
			err   error
			once  sync.Once
			value *Telecom
		)
		m.oldValue = func(ctx context.Context) (*Telecom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Telecom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTelecom sets the old Telecom of the mutation.
func withTelecom(node *Telecom) telecomOption {
	return func(m *TelecomMutation) {
		m.oldValue = func(context.Context) (*Telecom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TelecomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TelecomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TelecomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TelecomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Telecom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *TelecomMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TelecomMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Telecom entity.
// If the Telecom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelecomMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TelecomMutation) ResetEmail() {
	m.email = nil
}

// SetTelephone sets the "telephone" field.
func (m *TelecomMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *TelecomMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the Telecom entity.
// If the Telecom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelecomMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *TelecomMutation) ResetTelephone() {
	m.telephone = nil
}

// SetUsername sets the "username" field.
func (m *TelecomMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *TelecomMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Telecom entity.
// If the Telecom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelecomMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *TelecomMutation) ResetUsername() {
	m.username = nil
}

// SetPlatform sets the "platform" field.
func (m *TelecomMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *TelecomMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Telecom entity.
// If the Telecom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TelecomMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *TelecomMutation) ResetPlatform() {
	m.platform = nil
}

// SetWhoIsTheOwnerOfThisTelecomID sets the "who_is_the_owner_of_this_telecom" edge to the User entity by id.
func (m *TelecomMutation) SetWhoIsTheOwnerOfThisTelecomID(id int) {
	m.who_is_the_owner_of_this_telecom = &id
}

// ClearWhoIsTheOwnerOfThisTelecom clears the "who_is_the_owner_of_this_telecom" edge to the User entity.
func (m *TelecomMutation) ClearWhoIsTheOwnerOfThisTelecom() {
	m.clearedwho_is_the_owner_of_this_telecom = true
}

// WhoIsTheOwnerOfThisTelecomCleared reports if the "who_is_the_owner_of_this_telecom" edge to the User entity was cleared.
func (m *TelecomMutation) WhoIsTheOwnerOfThisTelecomCleared() bool {
	return m.clearedwho_is_the_owner_of_this_telecom
}

// WhoIsTheOwnerOfThisTelecomID returns the "who_is_the_owner_of_this_telecom" edge ID in the mutation.
func (m *TelecomMutation) WhoIsTheOwnerOfThisTelecomID() (id int, exists bool) {
	if m.who_is_the_owner_of_this_telecom != nil {
		return *m.who_is_the_owner_of_this_telecom, true
	}
	return
}

// WhoIsTheOwnerOfThisTelecomIDs returns the "who_is_the_owner_of_this_telecom" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WhoIsTheOwnerOfThisTelecomID instead. It exists only for internal usage by the builders.
func (m *TelecomMutation) WhoIsTheOwnerOfThisTelecomIDs() (ids []int) {
	if id := m.who_is_the_owner_of_this_telecom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWhoIsTheOwnerOfThisTelecom resets all changes to the "who_is_the_owner_of_this_telecom" edge.
func (m *TelecomMutation) ResetWhoIsTheOwnerOfThisTelecom() {
	m.who_is_the_owner_of_this_telecom = nil
	m.clearedwho_is_the_owner_of_this_telecom = false
}

// Where appends a list predicates to the TelecomMutation builder.
func (m *TelecomMutation) Where(ps ...predicate.Telecom) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TelecomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Telecom).
func (m *TelecomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TelecomMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, telecom.FieldEmail)
	}
	if m.telephone != nil {
		fields = append(fields, telecom.FieldTelephone)
	}
	if m.username != nil {
		fields = append(fields, telecom.FieldUsername)
	}
	if m.platform != nil {
		fields = append(fields, telecom.FieldPlatform)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TelecomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case telecom.FieldEmail:
		return m.Email()
	case telecom.FieldTelephone:
		return m.Telephone()
	case telecom.FieldUsername:
		return m.Username()
	case telecom.FieldPlatform:
		return m.Platform()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TelecomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case telecom.FieldEmail:
		return m.OldEmail(ctx)
	case telecom.FieldTelephone:
		return m.OldTelephone(ctx)
	case telecom.FieldUsername:
		return m.OldUsername(ctx)
	case telecom.FieldPlatform:
		return m.OldPlatform(ctx)
	}
	return nil, fmt.Errorf("unknown Telecom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelecomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case telecom.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case telecom.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case telecom.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case telecom.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	}
	return fmt.Errorf("unknown Telecom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TelecomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TelecomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TelecomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Telecom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TelecomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TelecomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TelecomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Telecom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TelecomMutation) ResetField(name string) error {
	switch name {
	case telecom.FieldEmail:
		m.ResetEmail()
		return nil
	case telecom.FieldTelephone:
		m.ResetTelephone()
		return nil
	case telecom.FieldUsername:
		m.ResetUsername()
		return nil
	case telecom.FieldPlatform:
		m.ResetPlatform()
		return nil
	}
	return fmt.Errorf("unknown Telecom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TelecomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.who_is_the_owner_of_this_telecom != nil {
		edges = append(edges, telecom.EdgeWhoIsTheOwnerOfThisTelecom)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TelecomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case telecom.EdgeWhoIsTheOwnerOfThisTelecom:
		if id := m.who_is_the_owner_of_this_telecom; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TelecomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TelecomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TelecomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwho_is_the_owner_of_this_telecom {
		edges = append(edges, telecom.EdgeWhoIsTheOwnerOfThisTelecom)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TelecomMutation) EdgeCleared(name string) bool {
	switch name {
	case telecom.EdgeWhoIsTheOwnerOfThisTelecom:
		return m.clearedwho_is_the_owner_of_this_telecom
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TelecomMutation) ClearEdge(name string) error {
	switch name {
	case telecom.EdgeWhoIsTheOwnerOfThisTelecom:
		m.ClearWhoIsTheOwnerOfThisTelecom()
		return nil
	}
	return fmt.Errorf("unknown Telecom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TelecomMutation) ResetEdge(name string) error {
	switch name {
	case telecom.EdgeWhoIsTheOwnerOfThisTelecom:
		m.ResetWhoIsTheOwnerOfThisTelecom()
		return nil
	}
	return fmt.Errorf("unknown Telecom edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	_AuthToken                  *string
	_GeneratedAt                *time.Time
	_ExpiresAt                  *time.Time
	clearedFields               map[string]struct{}
	authentication_token        *int
	clearedauthentication_token bool
	done                        bool
	oldValue                    func(context.Context) (*Token, error)
	predicates                  []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthToken sets the "AuthToken" field.
func (m *TokenMutation) SetAuthToken(s string) {
	m._AuthToken = &s
}

// AuthToken returns the value of the "AuthToken" field in the mutation.
func (m *TokenMutation) AuthToken() (r string, exists bool) {
	v := m._AuthToken
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthToken returns the old "AuthToken" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldAuthToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthToken: %w", err)
	}
	return oldValue.AuthToken, nil
}

// ResetAuthToken resets all changes to the "AuthToken" field.
func (m *TokenMutation) ResetAuthToken() {
	m._AuthToken = nil
}

// SetGeneratedAt sets the "GeneratedAt" field.
func (m *TokenMutation) SetGeneratedAt(t time.Time) {
	m._GeneratedAt = &t
}

// GeneratedAt returns the value of the "GeneratedAt" field in the mutation.
func (m *TokenMutation) GeneratedAt() (r time.Time, exists bool) {
	v := m._GeneratedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedAt returns the old "GeneratedAt" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldGeneratedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedAt: %w", err)
	}
	return oldValue.GeneratedAt, nil
}

// ClearGeneratedAt clears the value of the "GeneratedAt" field.
func (m *TokenMutation) ClearGeneratedAt() {
	m._GeneratedAt = nil
	m.clearedFields[token.FieldGeneratedAt] = struct{}{}
}

// GeneratedAtCleared returns if the "GeneratedAt" field was cleared in this mutation.
func (m *TokenMutation) GeneratedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldGeneratedAt]
	return ok
}

// ResetGeneratedAt resets all changes to the "GeneratedAt" field.
func (m *TokenMutation) ResetGeneratedAt() {
	m._GeneratedAt = nil
	delete(m.clearedFields, token.FieldGeneratedAt)
}

// SetExpiresAt sets the "ExpiresAt" field.
func (m *TokenMutation) SetExpiresAt(t time.Time) {
	m._ExpiresAt = &t
}

// ExpiresAt returns the value of the "ExpiresAt" field in the mutation.
func (m *TokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m._ExpiresAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "ExpiresAt" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "ExpiresAt" field.
func (m *TokenMutation) ClearExpiresAt() {
	m._ExpiresAt = nil
	m.clearedFields[token.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "ExpiresAt" field was cleared in this mutation.
func (m *TokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[token.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "ExpiresAt" field.
func (m *TokenMutation) ResetExpiresAt() {
	m._ExpiresAt = nil
	delete(m.clearedFields, token.FieldExpiresAt)
}

// SetAuthenticationTokenID sets the "authentication_token" edge to the User entity by id.
func (m *TokenMutation) SetAuthenticationTokenID(id int) {
	m.authentication_token = &id
}

// ClearAuthenticationToken clears the "authentication_token" edge to the User entity.
func (m *TokenMutation) ClearAuthenticationToken() {
	m.clearedauthentication_token = true
}

// AuthenticationTokenCleared reports if the "authentication_token" edge to the User entity was cleared.
func (m *TokenMutation) AuthenticationTokenCleared() bool {
	return m.clearedauthentication_token
}

// AuthenticationTokenID returns the "authentication_token" edge ID in the mutation.
func (m *TokenMutation) AuthenticationTokenID() (id int, exists bool) {
	if m.authentication_token != nil {
		return *m.authentication_token, true
	}
	return
}

// AuthenticationTokenIDs returns the "authentication_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthenticationTokenID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) AuthenticationTokenIDs() (ids []int) {
	if id := m.authentication_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthenticationToken resets all changes to the "authentication_token" edge.
func (m *TokenMutation) ResetAuthenticationToken() {
	m.authentication_token = nil
	m.clearedauthentication_token = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._AuthToken != nil {
		fields = append(fields, token.FieldAuthToken)
	}
	if m._GeneratedAt != nil {
		fields = append(fields, token.FieldGeneratedAt)
	}
	if m._ExpiresAt != nil {
		fields = append(fields, token.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldAuthToken:
		return m.AuthToken()
	case token.FieldGeneratedAt:
		return m.GeneratedAt()
	case token.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldAuthToken:
		return m.OldAuthToken(ctx)
	case token.FieldGeneratedAt:
		return m.OldGeneratedAt(ctx)
	case token.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldAuthToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthToken(v)
		return nil
	case token.FieldGeneratedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedAt(v)
		return nil
	case token.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldGeneratedAt) {
		fields = append(fields, token.FieldGeneratedAt)
	}
	if m.FieldCleared(token.FieldExpiresAt) {
		fields = append(fields, token.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldGeneratedAt:
		m.ClearGeneratedAt()
		return nil
	case token.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldAuthToken:
		m.ResetAuthToken()
		return nil
	case token.FieldGeneratedAt:
		m.ResetGeneratedAt()
		return nil
	case token.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.authentication_token != nil {
		edges = append(edges, token.EdgeAuthenticationToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeAuthenticationToken:
		if id := m.authentication_token; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthentication_token {
		edges = append(edges, token.EdgeAuthenticationToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeAuthenticationToken:
		return m.clearedauthentication_token
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeAuthenticationToken:
		m.ClearAuthenticationToken()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeAuthenticationToken:
		m.ResetAuthenticationToken()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TreatmentMutation represents an operation that mutates the Treatment nodes in the graph.
type TreatmentMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	treatmentRecord                         *string
	dateTime                                *time.Time
	takeTime                                *float64
	addtakeTime                             *float64
	clearedFields                           map[string]struct{}
	treatment_was_recorded_by_doctor        *int
	clearedtreatment_was_recorded_by_doctor bool
	user_is_the_treatment_of_record         *int
	cleareduser_is_the_treatment_of_record  bool
	done                                    bool
	oldValue                                func(context.Context) (*Treatment, error)
	predicates                              []predicate.Treatment
}

var _ ent.Mutation = (*TreatmentMutation)(nil)

// treatmentOption allows management of the mutation configuration using functional options.
type treatmentOption func(*TreatmentMutation)

// newTreatmentMutation creates new mutation for the Treatment entity.
func newTreatmentMutation(c config, op Op, opts ...treatmentOption) *TreatmentMutation {
	m := &TreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentID sets the ID field of the mutation.
func withTreatmentID(id int) treatmentOption {
	return func(m *TreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Treatment
		)
		m.oldValue = func(ctx context.Context) (*Treatment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Treatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatment sets the old Treatment of the mutation.
func withTreatment(node *Treatment) treatmentOption {
	return func(m *TreatmentMutation) {
		m.oldValue = func(context.Context) (*Treatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreatmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreatmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Treatment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTreatmentRecord sets the "treatmentRecord" field.
func (m *TreatmentMutation) SetTreatmentRecord(s string) {
	m.treatmentRecord = &s
}

// TreatmentRecord returns the value of the "treatmentRecord" field in the mutation.
func (m *TreatmentMutation) TreatmentRecord() (r string, exists bool) {
	v := m.treatmentRecord
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentRecord returns the old "treatmentRecord" field's value of the Treatment entity.
// If the Treatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreatmentMutation) OldTreatmentRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTreatmentRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTreatmentRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentRecord: %w", err)
	}
	return oldValue.TreatmentRecord, nil
}

// ResetTreatmentRecord resets all changes to the "treatmentRecord" field.
func (m *TreatmentMutation) ResetTreatmentRecord() {
	m.treatmentRecord = nil
}

// SetDateTime sets the "dateTime" field.
func (m *TreatmentMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *TreatmentMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the Treatment entity.
// If the Treatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreatmentMutation) OldDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "dateTime" field.
func (m *TreatmentMutation) ClearDateTime() {
	m.dateTime = nil
	m.clearedFields[treatment.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "dateTime" field was cleared in this mutation.
func (m *TreatmentMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[treatment.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *TreatmentMutation) ResetDateTime() {
	m.dateTime = nil
	delete(m.clearedFields, treatment.FieldDateTime)
}

// SetTakeTime sets the "takeTime" field.
func (m *TreatmentMutation) SetTakeTime(f float64) {
	m.takeTime = &f
	m.addtakeTime = nil
}

// TakeTime returns the value of the "takeTime" field in the mutation.
func (m *TreatmentMutation) TakeTime() (r float64, exists bool) {
	v := m.takeTime
	if v == nil {
		return
	}
	return *v, true
}

// OldTakeTime returns the old "takeTime" field's value of the Treatment entity.
// If the Treatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreatmentMutation) OldTakeTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakeTime: %w", err)
	}
	return oldValue.TakeTime, nil
}

// AddTakeTime adds f to the "takeTime" field.
func (m *TreatmentMutation) AddTakeTime(f float64) {
	if m.addtakeTime != nil {
		*m.addtakeTime += f
	} else {
		m.addtakeTime = &f
	}
}

// AddedTakeTime returns the value that was added to the "takeTime" field in this mutation.
func (m *TreatmentMutation) AddedTakeTime() (r float64, exists bool) {
	v := m.addtakeTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTakeTime resets all changes to the "takeTime" field.
func (m *TreatmentMutation) ResetTakeTime() {
	m.takeTime = nil
	m.addtakeTime = nil
}

// SetTreatmentWasRecordedByDoctorID sets the "treatment_was_recorded_by_doctor" edge to the User entity by id.
func (m *TreatmentMutation) SetTreatmentWasRecordedByDoctorID(id int) {
	m.treatment_was_recorded_by_doctor = &id
}

// ClearTreatmentWasRecordedByDoctor clears the "treatment_was_recorded_by_doctor" edge to the User entity.
func (m *TreatmentMutation) ClearTreatmentWasRecordedByDoctor() {
	m.clearedtreatment_was_recorded_by_doctor = true
}

// TreatmentWasRecordedByDoctorCleared reports if the "treatment_was_recorded_by_doctor" edge to the User entity was cleared.
func (m *TreatmentMutation) TreatmentWasRecordedByDoctorCleared() bool {
	return m.clearedtreatment_was_recorded_by_doctor
}

// TreatmentWasRecordedByDoctorID returns the "treatment_was_recorded_by_doctor" edge ID in the mutation.
func (m *TreatmentMutation) TreatmentWasRecordedByDoctorID() (id int, exists bool) {
	if m.treatment_was_recorded_by_doctor != nil {
		return *m.treatment_was_recorded_by_doctor, true
	}
	return
}

// TreatmentWasRecordedByDoctorIDs returns the "treatment_was_recorded_by_doctor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreatmentWasRecordedByDoctorID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) TreatmentWasRecordedByDoctorIDs() (ids []int) {
	if id := m.treatment_was_recorded_by_doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreatmentWasRecordedByDoctor resets all changes to the "treatment_was_recorded_by_doctor" edge.
func (m *TreatmentMutation) ResetTreatmentWasRecordedByDoctor() {
	m.treatment_was_recorded_by_doctor = nil
	m.clearedtreatment_was_recorded_by_doctor = false
}

// SetUserIsTheTreatmentOfRecordID sets the "user_is_the_treatment_of_record" edge to the User entity by id.
func (m *TreatmentMutation) SetUserIsTheTreatmentOfRecordID(id int) {
	m.user_is_the_treatment_of_record = &id
}

// ClearUserIsTheTreatmentOfRecord clears the "user_is_the_treatment_of_record" edge to the User entity.
func (m *TreatmentMutation) ClearUserIsTheTreatmentOfRecord() {
	m.cleareduser_is_the_treatment_of_record = true
}

// UserIsTheTreatmentOfRecordCleared reports if the "user_is_the_treatment_of_record" edge to the User entity was cleared.
func (m *TreatmentMutation) UserIsTheTreatmentOfRecordCleared() bool {
	return m.cleareduser_is_the_treatment_of_record
}

// UserIsTheTreatmentOfRecordID returns the "user_is_the_treatment_of_record" edge ID in the mutation.
func (m *TreatmentMutation) UserIsTheTreatmentOfRecordID() (id int, exists bool) {
	if m.user_is_the_treatment_of_record != nil {
		return *m.user_is_the_treatment_of_record, true
	}
	return
}

// UserIsTheTreatmentOfRecordIDs returns the "user_is_the_treatment_of_record" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserIsTheTreatmentOfRecordID instead. It exists only for internal usage by the builders.
func (m *TreatmentMutation) UserIsTheTreatmentOfRecordIDs() (ids []int) {
	if id := m.user_is_the_treatment_of_record; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserIsTheTreatmentOfRecord resets all changes to the "user_is_the_treatment_of_record" edge.
func (m *TreatmentMutation) ResetUserIsTheTreatmentOfRecord() {
	m.user_is_the_treatment_of_record = nil
	m.cleareduser_is_the_treatment_of_record = false
}

// Where appends a list predicates to the TreatmentMutation builder.
func (m *TreatmentMutation) Where(ps ...predicate.Treatment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TreatmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Treatment).
func (m *TreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreatmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.treatmentRecord != nil {
		fields = append(fields, treatment.FieldTreatmentRecord)
	}
	if m.dateTime != nil {
		fields = append(fields, treatment.FieldDateTime)
	}
	if m.takeTime != nil {
		fields = append(fields, treatment.FieldTakeTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatment.FieldTreatmentRecord:
		return m.TreatmentRecord()
	case treatment.FieldDateTime:
		return m.DateTime()
	case treatment.FieldTakeTime:
		return m.TakeTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatment.FieldTreatmentRecord:
		return m.OldTreatmentRecord(ctx)
	case treatment.FieldDateTime:
		return m.OldDateTime(ctx)
	case treatment.FieldTakeTime:
		return m.OldTakeTime(ctx)
	}
	return nil, fmt.Errorf("unknown Treatment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatment.FieldTreatmentRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentRecord(v)
		return nil
	case treatment.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case treatment.FieldTakeTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakeTime(v)
		return nil
	}
	return fmt.Errorf("unknown Treatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreatmentMutation) AddedFields() []string {
	var fields []string
	if m.addtakeTime != nil {
		fields = append(fields, treatment.FieldTakeTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreatmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treatment.FieldTakeTime:
		return m.AddedTakeTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treatment.FieldTakeTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTakeTime(v)
		return nil
	}
	return fmt.Errorf("unknown Treatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreatmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treatment.FieldDateTime) {
		fields = append(fields, treatment.FieldDateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentMutation) ClearField(name string) error {
	switch name {
	case treatment.FieldDateTime:
		m.ClearDateTime()
		return nil
	}
	return fmt.Errorf("unknown Treatment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreatmentMutation) ResetField(name string) error {
	switch name {
	case treatment.FieldTreatmentRecord:
		m.ResetTreatmentRecord()
		return nil
	case treatment.FieldDateTime:
		m.ResetDateTime()
		return nil
	case treatment.FieldTakeTime:
		m.ResetTakeTime()
		return nil
	}
	return fmt.Errorf("unknown Treatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.treatment_was_recorded_by_doctor != nil {
		edges = append(edges, treatment.EdgeTreatmentWasRecordedByDoctor)
	}
	if m.user_is_the_treatment_of_record != nil {
		edges = append(edges, treatment.EdgeUserIsTheTreatmentOfRecord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treatment.EdgeTreatmentWasRecordedByDoctor:
		if id := m.treatment_was_recorded_by_doctor; id != nil {
			return []ent.Value{*id}
		}
	case treatment.EdgeUserIsTheTreatmentOfRecord:
		if id := m.user_is_the_treatment_of_record; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreatmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtreatment_was_recorded_by_doctor {
		edges = append(edges, treatment.EdgeTreatmentWasRecordedByDoctor)
	}
	if m.cleareduser_is_the_treatment_of_record {
		edges = append(edges, treatment.EdgeUserIsTheTreatmentOfRecord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	case treatment.EdgeTreatmentWasRecordedByDoctor:
		return m.clearedtreatment_was_recorded_by_doctor
	case treatment.EdgeUserIsTheTreatmentOfRecord:
		return m.cleareduser_is_the_treatment_of_record
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreatmentMutation) ClearEdge(name string) error {
	switch name {
	case treatment.EdgeTreatmentWasRecordedByDoctor:
		m.ClearTreatmentWasRecordedByDoctor()
		return nil
	case treatment.EdgeUserIsTheTreatmentOfRecord:
		m.ClearUserIsTheTreatmentOfRecord()
		return nil
	}
	return fmt.Errorf("unknown Treatment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreatmentMutation) ResetEdge(name string) error {
	switch name {
	case treatment.EdgeTreatmentWasRecordedByDoctor:
		m.ResetTreatmentWasRecordedByDoctor()
		return nil
	case treatment.EdgeUserIsTheTreatmentOfRecord:
		m.ResetUserIsTheTreatmentOfRecord()
		return nil
	}
	return fmt.Errorf("unknown Treatment edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	username                        *string
	password                        *string
	clearedFields                   map[string]struct{}
	doctor_has_certification        map[int]struct{}
	removeddoctor_has_certification map[int]struct{}
	cleareddoctor_has_certification bool
	user_has_PInfo                  map[int]struct{}
	removeduser_has_PInfo           map[int]struct{}
	cleareduser_has_PInfo           bool
	doctor_schedule                 map[int]struct{}
	removeddoctor_schedule          map[int]struct{}
	cleareddoctor_schedule          bool
	user_have_telecoms              map[int]struct{}
	removeduser_have_telecoms       map[int]struct{}
	cleareduser_have_telecoms       bool
	doctor_record_treatment         map[int]struct{}
	removeddoctor_record_treatment  map[int]struct{}
	cleareddoctor_record_treatment  bool
	user_have_treatment             map[int]struct{}
	removeduser_have_treatment      map[int]struct{}
	cleareduser_have_treatment      bool
	user_have_token                 map[int]struct{}
	removeduser_have_token          map[int]struct{}
	cleareduser_have_token          bool
	user_send_message               map[int]struct{}
	removeduser_send_message        map[int]struct{}
	cleareduser_send_message        bool
	user_send_notification          map[int]struct{}
	removeduser_send_notification   map[int]struct{}
	cleareduser_send_notification   bool
	has_department                  *int
	clearedhas_department           bool
	from_hospital                   *int
	clearedfrom_hospital            bool
	user_have_disease               map[int]struct{}
	removeduser_have_disease        map[int]struct{}
	cleareduser_have_disease        bool
	user_have_role                  map[int]struct{}
	removeduser_have_role           map[int]struct{}
	cleareduser_have_role           bool
	who_is_in_this_chat             map[int]struct{}
	removedwho_is_in_this_chat      map[int]struct{}
	clearedwho_is_in_this_chat      bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// AddDoctorHasCertificationIDs adds the "doctor_has_certification" edge to the Certification entity by ids.
func (m *UserMutation) AddDoctorHasCertificationIDs(ids ...int) {
	if m.doctor_has_certification == nil {
		m.doctor_has_certification = make(map[int]struct{})
	}
	for i := range ids {
		m.doctor_has_certification[ids[i]] = struct{}{}
	}
}

// ClearDoctorHasCertification clears the "doctor_has_certification" edge to the Certification entity.
func (m *UserMutation) ClearDoctorHasCertification() {
	m.cleareddoctor_has_certification = true
}

// DoctorHasCertificationCleared reports if the "doctor_has_certification" edge to the Certification entity was cleared.
func (m *UserMutation) DoctorHasCertificationCleared() bool {
	return m.cleareddoctor_has_certification
}

// RemoveDoctorHasCertificationIDs removes the "doctor_has_certification" edge to the Certification entity by IDs.
func (m *UserMutation) RemoveDoctorHasCertificationIDs(ids ...int) {
	if m.removeddoctor_has_certification == nil {
		m.removeddoctor_has_certification = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.doctor_has_certification, ids[i])
		m.removeddoctor_has_certification[ids[i]] = struct{}{}
	}
}

// RemovedDoctorHasCertification returns the removed IDs of the "doctor_has_certification" edge to the Certification entity.
func (m *UserMutation) RemovedDoctorHasCertificationIDs() (ids []int) {
	for id := range m.removeddoctor_has_certification {
		ids = append(ids, id)
	}
	return
}

// DoctorHasCertificationIDs returns the "doctor_has_certification" edge IDs in the mutation.
func (m *UserMutation) DoctorHasCertificationIDs() (ids []int) {
	for id := range m.doctor_has_certification {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorHasCertification resets all changes to the "doctor_has_certification" edge.
func (m *UserMutation) ResetDoctorHasCertification() {
	m.doctor_has_certification = nil
	m.cleareddoctor_has_certification = false
	m.removeddoctor_has_certification = nil
}

// AddUserHasPInfoIDs adds the "user_has_PInfo" edge to the PInfo entity by ids.
func (m *UserMutation) AddUserHasPInfoIDs(ids ...int) {
	if m.user_has_PInfo == nil {
		m.user_has_PInfo = make(map[int]struct{})
	}
	for i := range ids {
		m.user_has_PInfo[ids[i]] = struct{}{}
	}
}

// ClearUserHasPInfo clears the "user_has_PInfo" edge to the PInfo entity.
func (m *UserMutation) ClearUserHasPInfo() {
	m.cleareduser_has_PInfo = true
}

// UserHasPInfoCleared reports if the "user_has_PInfo" edge to the PInfo entity was cleared.
func (m *UserMutation) UserHasPInfoCleared() bool {
	return m.cleareduser_has_PInfo
}

// RemoveUserHasPInfoIDs removes the "user_has_PInfo" edge to the PInfo entity by IDs.
func (m *UserMutation) RemoveUserHasPInfoIDs(ids ...int) {
	if m.removeduser_has_PInfo == nil {
		m.removeduser_has_PInfo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_has_PInfo, ids[i])
		m.removeduser_has_PInfo[ids[i]] = struct{}{}
	}
}

// RemovedUserHasPInfo returns the removed IDs of the "user_has_PInfo" edge to the PInfo entity.
func (m *UserMutation) RemovedUserHasPInfoIDs() (ids []int) {
	for id := range m.removeduser_has_PInfo {
		ids = append(ids, id)
	}
	return
}

// UserHasPInfoIDs returns the "user_has_PInfo" edge IDs in the mutation.
func (m *UserMutation) UserHasPInfoIDs() (ids []int) {
	for id := range m.user_has_PInfo {
		ids = append(ids, id)
	}
	return
}

// ResetUserHasPInfo resets all changes to the "user_has_PInfo" edge.
func (m *UserMutation) ResetUserHasPInfo() {
	m.user_has_PInfo = nil
	m.cleareduser_has_PInfo = false
	m.removeduser_has_PInfo = nil
}

// AddDoctorScheduleIDs adds the "doctor_schedule" edge to the Schedule entity by ids.
func (m *UserMutation) AddDoctorScheduleIDs(ids ...int) {
	if m.doctor_schedule == nil {
		m.doctor_schedule = make(map[int]struct{})
	}
	for i := range ids {
		m.doctor_schedule[ids[i]] = struct{}{}
	}
}

// ClearDoctorSchedule clears the "doctor_schedule" edge to the Schedule entity.
func (m *UserMutation) ClearDoctorSchedule() {
	m.cleareddoctor_schedule = true
}

// DoctorScheduleCleared reports if the "doctor_schedule" edge to the Schedule entity was cleared.
func (m *UserMutation) DoctorScheduleCleared() bool {
	return m.cleareddoctor_schedule
}

// RemoveDoctorScheduleIDs removes the "doctor_schedule" edge to the Schedule entity by IDs.
func (m *UserMutation) RemoveDoctorScheduleIDs(ids ...int) {
	if m.removeddoctor_schedule == nil {
		m.removeddoctor_schedule = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.doctor_schedule, ids[i])
		m.removeddoctor_schedule[ids[i]] = struct{}{}
	}
}

// RemovedDoctorSchedule returns the removed IDs of the "doctor_schedule" edge to the Schedule entity.
func (m *UserMutation) RemovedDoctorScheduleIDs() (ids []int) {
	for id := range m.removeddoctor_schedule {
		ids = append(ids, id)
	}
	return
}

// DoctorScheduleIDs returns the "doctor_schedule" edge IDs in the mutation.
func (m *UserMutation) DoctorScheduleIDs() (ids []int) {
	for id := range m.doctor_schedule {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorSchedule resets all changes to the "doctor_schedule" edge.
func (m *UserMutation) ResetDoctorSchedule() {
	m.doctor_schedule = nil
	m.cleareddoctor_schedule = false
	m.removeddoctor_schedule = nil
}

// AddUserHaveTelecomIDs adds the "user_have_telecoms" edge to the Telecom entity by ids.
func (m *UserMutation) AddUserHaveTelecomIDs(ids ...int) {
	if m.user_have_telecoms == nil {
		m.user_have_telecoms = make(map[int]struct{})
	}
	for i := range ids {
		m.user_have_telecoms[ids[i]] = struct{}{}
	}
}

// ClearUserHaveTelecoms clears the "user_have_telecoms" edge to the Telecom entity.
func (m *UserMutation) ClearUserHaveTelecoms() {
	m.cleareduser_have_telecoms = true
}

// UserHaveTelecomsCleared reports if the "user_have_telecoms" edge to the Telecom entity was cleared.
func (m *UserMutation) UserHaveTelecomsCleared() bool {
	return m.cleareduser_have_telecoms
}

// RemoveUserHaveTelecomIDs removes the "user_have_telecoms" edge to the Telecom entity by IDs.
func (m *UserMutation) RemoveUserHaveTelecomIDs(ids ...int) {
	if m.removeduser_have_telecoms == nil {
		m.removeduser_have_telecoms = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_have_telecoms, ids[i])
		m.removeduser_have_telecoms[ids[i]] = struct{}{}
	}
}

// RemovedUserHaveTelecoms returns the removed IDs of the "user_have_telecoms" edge to the Telecom entity.
func (m *UserMutation) RemovedUserHaveTelecomsIDs() (ids []int) {
	for id := range m.removeduser_have_telecoms {
		ids = append(ids, id)
	}
	return
}

// UserHaveTelecomsIDs returns the "user_have_telecoms" edge IDs in the mutation.
func (m *UserMutation) UserHaveTelecomsIDs() (ids []int) {
	for id := range m.user_have_telecoms {
		ids = append(ids, id)
	}
	return
}

// ResetUserHaveTelecoms resets all changes to the "user_have_telecoms" edge.
func (m *UserMutation) ResetUserHaveTelecoms() {
	m.user_have_telecoms = nil
	m.cleareduser_have_telecoms = false
	m.removeduser_have_telecoms = nil
}

// AddDoctorRecordTreatmentIDs adds the "doctor_record_treatment" edge to the Treatment entity by ids.
func (m *UserMutation) AddDoctorRecordTreatmentIDs(ids ...int) {
	if m.doctor_record_treatment == nil {
		m.doctor_record_treatment = make(map[int]struct{})
	}
	for i := range ids {
		m.doctor_record_treatment[ids[i]] = struct{}{}
	}
}

// ClearDoctorRecordTreatment clears the "doctor_record_treatment" edge to the Treatment entity.
func (m *UserMutation) ClearDoctorRecordTreatment() {
	m.cleareddoctor_record_treatment = true
}

// DoctorRecordTreatmentCleared reports if the "doctor_record_treatment" edge to the Treatment entity was cleared.
func (m *UserMutation) DoctorRecordTreatmentCleared() bool {
	return m.cleareddoctor_record_treatment
}

// RemoveDoctorRecordTreatmentIDs removes the "doctor_record_treatment" edge to the Treatment entity by IDs.
func (m *UserMutation) RemoveDoctorRecordTreatmentIDs(ids ...int) {
	if m.removeddoctor_record_treatment == nil {
		m.removeddoctor_record_treatment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.doctor_record_treatment, ids[i])
		m.removeddoctor_record_treatment[ids[i]] = struct{}{}
	}
}

// RemovedDoctorRecordTreatment returns the removed IDs of the "doctor_record_treatment" edge to the Treatment entity.
func (m *UserMutation) RemovedDoctorRecordTreatmentIDs() (ids []int) {
	for id := range m.removeddoctor_record_treatment {
		ids = append(ids, id)
	}
	return
}

// DoctorRecordTreatmentIDs returns the "doctor_record_treatment" edge IDs in the mutation.
func (m *UserMutation) DoctorRecordTreatmentIDs() (ids []int) {
	for id := range m.doctor_record_treatment {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorRecordTreatment resets all changes to the "doctor_record_treatment" edge.
func (m *UserMutation) ResetDoctorRecordTreatment() {
	m.doctor_record_treatment = nil
	m.cleareddoctor_record_treatment = false
	m.removeddoctor_record_treatment = nil
}

// AddUserHaveTreatmentIDs adds the "user_have_treatment" edge to the Treatment entity by ids.
func (m *UserMutation) AddUserHaveTreatmentIDs(ids ...int) {
	if m.user_have_treatment == nil {
		m.user_have_treatment = make(map[int]struct{})
	}
	for i := range ids {
		m.user_have_treatment[ids[i]] = struct{}{}
	}
}

// ClearUserHaveTreatment clears the "user_have_treatment" edge to the Treatment entity.
func (m *UserMutation) ClearUserHaveTreatment() {
	m.cleareduser_have_treatment = true
}

// UserHaveTreatmentCleared reports if the "user_have_treatment" edge to the Treatment entity was cleared.
func (m *UserMutation) UserHaveTreatmentCleared() bool {
	return m.cleareduser_have_treatment
}

// RemoveUserHaveTreatmentIDs removes the "user_have_treatment" edge to the Treatment entity by IDs.
func (m *UserMutation) RemoveUserHaveTreatmentIDs(ids ...int) {
	if m.removeduser_have_treatment == nil {
		m.removeduser_have_treatment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_have_treatment, ids[i])
		m.removeduser_have_treatment[ids[i]] = struct{}{}
	}
}

// RemovedUserHaveTreatment returns the removed IDs of the "user_have_treatment" edge to the Treatment entity.
func (m *UserMutation) RemovedUserHaveTreatmentIDs() (ids []int) {
	for id := range m.removeduser_have_treatment {
		ids = append(ids, id)
	}
	return
}

// UserHaveTreatmentIDs returns the "user_have_treatment" edge IDs in the mutation.
func (m *UserMutation) UserHaveTreatmentIDs() (ids []int) {
	for id := range m.user_have_treatment {
		ids = append(ids, id)
	}
	return
}

// ResetUserHaveTreatment resets all changes to the "user_have_treatment" edge.
func (m *UserMutation) ResetUserHaveTreatment() {
	m.user_have_treatment = nil
	m.cleareduser_have_treatment = false
	m.removeduser_have_treatment = nil
}

// AddUserHaveTokenIDs adds the "user_have_token" edge to the Token entity by ids.
func (m *UserMutation) AddUserHaveTokenIDs(ids ...int) {
	if m.user_have_token == nil {
		m.user_have_token = make(map[int]struct{})
	}
	for i := range ids {
		m.user_have_token[ids[i]] = struct{}{}
	}
}

// ClearUserHaveToken clears the "user_have_token" edge to the Token entity.
func (m *UserMutation) ClearUserHaveToken() {
	m.cleareduser_have_token = true
}

// UserHaveTokenCleared reports if the "user_have_token" edge to the Token entity was cleared.
func (m *UserMutation) UserHaveTokenCleared() bool {
	return m.cleareduser_have_token
}

// RemoveUserHaveTokenIDs removes the "user_have_token" edge to the Token entity by IDs.
func (m *UserMutation) RemoveUserHaveTokenIDs(ids ...int) {
	if m.removeduser_have_token == nil {
		m.removeduser_have_token = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_have_token, ids[i])
		m.removeduser_have_token[ids[i]] = struct{}{}
	}
}

// RemovedUserHaveToken returns the removed IDs of the "user_have_token" edge to the Token entity.
func (m *UserMutation) RemovedUserHaveTokenIDs() (ids []int) {
	for id := range m.removeduser_have_token {
		ids = append(ids, id)
	}
	return
}

// UserHaveTokenIDs returns the "user_have_token" edge IDs in the mutation.
func (m *UserMutation) UserHaveTokenIDs() (ids []int) {
	for id := range m.user_have_token {
		ids = append(ids, id)
	}
	return
}

// ResetUserHaveToken resets all changes to the "user_have_token" edge.
func (m *UserMutation) ResetUserHaveToken() {
	m.user_have_token = nil
	m.cleareduser_have_token = false
	m.removeduser_have_token = nil
}

// AddUserSendMessageIDs adds the "user_send_message" edge to the Message entity by ids.
func (m *UserMutation) AddUserSendMessageIDs(ids ...int) {
	if m.user_send_message == nil {
		m.user_send_message = make(map[int]struct{})
	}
	for i := range ids {
		m.user_send_message[ids[i]] = struct{}{}
	}
}

// ClearUserSendMessage clears the "user_send_message" edge to the Message entity.
func (m *UserMutation) ClearUserSendMessage() {
	m.cleareduser_send_message = true
}

// UserSendMessageCleared reports if the "user_send_message" edge to the Message entity was cleared.
func (m *UserMutation) UserSendMessageCleared() bool {
	return m.cleareduser_send_message
}

// RemoveUserSendMessageIDs removes the "user_send_message" edge to the Message entity by IDs.
func (m *UserMutation) RemoveUserSendMessageIDs(ids ...int) {
	if m.removeduser_send_message == nil {
		m.removeduser_send_message = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_send_message, ids[i])
		m.removeduser_send_message[ids[i]] = struct{}{}
	}
}

// RemovedUserSendMessage returns the removed IDs of the "user_send_message" edge to the Message entity.
func (m *UserMutation) RemovedUserSendMessageIDs() (ids []int) {
	for id := range m.removeduser_send_message {
		ids = append(ids, id)
	}
	return
}

// UserSendMessageIDs returns the "user_send_message" edge IDs in the mutation.
func (m *UserMutation) UserSendMessageIDs() (ids []int) {
	for id := range m.user_send_message {
		ids = append(ids, id)
	}
	return
}

// ResetUserSendMessage resets all changes to the "user_send_message" edge.
func (m *UserMutation) ResetUserSendMessage() {
	m.user_send_message = nil
	m.cleareduser_send_message = false
	m.removeduser_send_message = nil
}

// AddUserSendNotificationIDs adds the "user_send_notification" edge to the Notification entity by ids.
func (m *UserMutation) AddUserSendNotificationIDs(ids ...int) {
	if m.user_send_notification == nil {
		m.user_send_notification = make(map[int]struct{})
	}
	for i := range ids {
		m.user_send_notification[ids[i]] = struct{}{}
	}
}

// ClearUserSendNotification clears the "user_send_notification" edge to the Notification entity.
func (m *UserMutation) ClearUserSendNotification() {
	m.cleareduser_send_notification = true
}

// UserSendNotificationCleared reports if the "user_send_notification" edge to the Notification entity was cleared.
func (m *UserMutation) UserSendNotificationCleared() bool {
	return m.cleareduser_send_notification
}

// RemoveUserSendNotificationIDs removes the "user_send_notification" edge to the Notification entity by IDs.
func (m *UserMutation) RemoveUserSendNotificationIDs(ids ...int) {
	if m.removeduser_send_notification == nil {
		m.removeduser_send_notification = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_send_notification, ids[i])
		m.removeduser_send_notification[ids[i]] = struct{}{}
	}
}

// RemovedUserSendNotification returns the removed IDs of the "user_send_notification" edge to the Notification entity.
func (m *UserMutation) RemovedUserSendNotificationIDs() (ids []int) {
	for id := range m.removeduser_send_notification {
		ids = append(ids, id)
	}
	return
}

// UserSendNotificationIDs returns the "user_send_notification" edge IDs in the mutation.
func (m *UserMutation) UserSendNotificationIDs() (ids []int) {
	for id := range m.user_send_notification {
		ids = append(ids, id)
	}
	return
}

// ResetUserSendNotification resets all changes to the "user_send_notification" edge.
func (m *UserMutation) ResetUserSendNotification() {
	m.user_send_notification = nil
	m.cleareduser_send_notification = false
	m.removeduser_send_notification = nil
}

// SetHasDepartmentID sets the "has_department" edge to the Department entity by id.
func (m *UserMutation) SetHasDepartmentID(id int) {
	m.has_department = &id
}

// ClearHasDepartment clears the "has_department" edge to the Department entity.
func (m *UserMutation) ClearHasDepartment() {
	m.clearedhas_department = true
}

// HasDepartmentCleared reports if the "has_department" edge to the Department entity was cleared.
func (m *UserMutation) HasDepartmentCleared() bool {
	return m.clearedhas_department
}

// HasDepartmentID returns the "has_department" edge ID in the mutation.
func (m *UserMutation) HasDepartmentID() (id int, exists bool) {
	if m.has_department != nil {
		return *m.has_department, true
	}
	return
}

// HasDepartmentIDs returns the "has_department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HasDepartmentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) HasDepartmentIDs() (ids []int) {
	if id := m.has_department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasDepartment resets all changes to the "has_department" edge.
func (m *UserMutation) ResetHasDepartment() {
	m.has_department = nil
	m.clearedhas_department = false
}

// SetFromHospitalID sets the "from_hospital" edge to the Hospital entity by id.
func (m *UserMutation) SetFromHospitalID(id int) {
	m.from_hospital = &id
}

// ClearFromHospital clears the "from_hospital" edge to the Hospital entity.
func (m *UserMutation) ClearFromHospital() {
	m.clearedfrom_hospital = true
}

// FromHospitalCleared reports if the "from_hospital" edge to the Hospital entity was cleared.
func (m *UserMutation) FromHospitalCleared() bool {
	return m.clearedfrom_hospital
}

// FromHospitalID returns the "from_hospital" edge ID in the mutation.
func (m *UserMutation) FromHospitalID() (id int, exists bool) {
	if m.from_hospital != nil {
		return *m.from_hospital, true
	}
	return
}

// FromHospitalIDs returns the "from_hospital" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromHospitalID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FromHospitalIDs() (ids []int) {
	if id := m.from_hospital; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromHospital resets all changes to the "from_hospital" edge.
func (m *UserMutation) ResetFromHospital() {
	m.from_hospital = nil
	m.clearedfrom_hospital = false
}

// AddUserHaveDiseaseIDs adds the "user_have_disease" edge to the Disease entity by ids.
func (m *UserMutation) AddUserHaveDiseaseIDs(ids ...int) {
	if m.user_have_disease == nil {
		m.user_have_disease = make(map[int]struct{})
	}
	for i := range ids {
		m.user_have_disease[ids[i]] = struct{}{}
	}
}

// ClearUserHaveDisease clears the "user_have_disease" edge to the Disease entity.
func (m *UserMutation) ClearUserHaveDisease() {
	m.cleareduser_have_disease = true
}

// UserHaveDiseaseCleared reports if the "user_have_disease" edge to the Disease entity was cleared.
func (m *UserMutation) UserHaveDiseaseCleared() bool {
	return m.cleareduser_have_disease
}

// RemoveUserHaveDiseaseIDs removes the "user_have_disease" edge to the Disease entity by IDs.
func (m *UserMutation) RemoveUserHaveDiseaseIDs(ids ...int) {
	if m.removeduser_have_disease == nil {
		m.removeduser_have_disease = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_have_disease, ids[i])
		m.removeduser_have_disease[ids[i]] = struct{}{}
	}
}

// RemovedUserHaveDisease returns the removed IDs of the "user_have_disease" edge to the Disease entity.
func (m *UserMutation) RemovedUserHaveDiseaseIDs() (ids []int) {
	for id := range m.removeduser_have_disease {
		ids = append(ids, id)
	}
	return
}

// UserHaveDiseaseIDs returns the "user_have_disease" edge IDs in the mutation.
func (m *UserMutation) UserHaveDiseaseIDs() (ids []int) {
	for id := range m.user_have_disease {
		ids = append(ids, id)
	}
	return
}

// ResetUserHaveDisease resets all changes to the "user_have_disease" edge.
func (m *UserMutation) ResetUserHaveDisease() {
	m.user_have_disease = nil
	m.cleareduser_have_disease = false
	m.removeduser_have_disease = nil
}

// AddUserHaveRoleIDs adds the "user_have_role" edge to the Role entity by ids.
func (m *UserMutation) AddUserHaveRoleIDs(ids ...int) {
	if m.user_have_role == nil {
		m.user_have_role = make(map[int]struct{})
	}
	for i := range ids {
		m.user_have_role[ids[i]] = struct{}{}
	}
}

// ClearUserHaveRole clears the "user_have_role" edge to the Role entity.
func (m *UserMutation) ClearUserHaveRole() {
	m.cleareduser_have_role = true
}

// UserHaveRoleCleared reports if the "user_have_role" edge to the Role entity was cleared.
func (m *UserMutation) UserHaveRoleCleared() bool {
	return m.cleareduser_have_role
}

// RemoveUserHaveRoleIDs removes the "user_have_role" edge to the Role entity by IDs.
func (m *UserMutation) RemoveUserHaveRoleIDs(ids ...int) {
	if m.removeduser_have_role == nil {
		m.removeduser_have_role = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_have_role, ids[i])
		m.removeduser_have_role[ids[i]] = struct{}{}
	}
}

// RemovedUserHaveRole returns the removed IDs of the "user_have_role" edge to the Role entity.
func (m *UserMutation) RemovedUserHaveRoleIDs() (ids []int) {
	for id := range m.removeduser_have_role {
		ids = append(ids, id)
	}
	return
}

// UserHaveRoleIDs returns the "user_have_role" edge IDs in the mutation.
func (m *UserMutation) UserHaveRoleIDs() (ids []int) {
	for id := range m.user_have_role {
		ids = append(ids, id)
	}
	return
}

// ResetUserHaveRole resets all changes to the "user_have_role" edge.
func (m *UserMutation) ResetUserHaveRole() {
	m.user_have_role = nil
	m.cleareduser_have_role = false
	m.removeduser_have_role = nil
}

// AddWhoIsInThisChatIDs adds the "who_is_in_this_chat" edge to the Chat entity by ids.
func (m *UserMutation) AddWhoIsInThisChatIDs(ids ...int) {
	if m.who_is_in_this_chat == nil {
		m.who_is_in_this_chat = make(map[int]struct{})
	}
	for i := range ids {
		m.who_is_in_this_chat[ids[i]] = struct{}{}
	}
}

// ClearWhoIsInThisChat clears the "who_is_in_this_chat" edge to the Chat entity.
func (m *UserMutation) ClearWhoIsInThisChat() {
	m.clearedwho_is_in_this_chat = true
}

// WhoIsInThisChatCleared reports if the "who_is_in_this_chat" edge to the Chat entity was cleared.
func (m *UserMutation) WhoIsInThisChatCleared() bool {
	return m.clearedwho_is_in_this_chat
}

// RemoveWhoIsInThisChatIDs removes the "who_is_in_this_chat" edge to the Chat entity by IDs.
func (m *UserMutation) RemoveWhoIsInThisChatIDs(ids ...int) {
	if m.removedwho_is_in_this_chat == nil {
		m.removedwho_is_in_this_chat = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.who_is_in_this_chat, ids[i])
		m.removedwho_is_in_this_chat[ids[i]] = struct{}{}
	}
}

// RemovedWhoIsInThisChat returns the removed IDs of the "who_is_in_this_chat" edge to the Chat entity.
func (m *UserMutation) RemovedWhoIsInThisChatIDs() (ids []int) {
	for id := range m.removedwho_is_in_this_chat {
		ids = append(ids, id)
	}
	return
}

// WhoIsInThisChatIDs returns the "who_is_in_this_chat" edge IDs in the mutation.
func (m *UserMutation) WhoIsInThisChatIDs() (ids []int) {
	for id := range m.who_is_in_this_chat {
		ids = append(ids, id)
	}
	return
}

// ResetWhoIsInThisChat resets all changes to the "who_is_in_this_chat" edge.
func (m *UserMutation) ResetWhoIsInThisChat() {
	m.who_is_in_this_chat = nil
	m.clearedwho_is_in_this_chat = false
	m.removedwho_is_in_this_chat = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.doctor_has_certification != nil {
		edges = append(edges, user.EdgeDoctorHasCertification)
	}
	if m.user_has_PInfo != nil {
		edges = append(edges, user.EdgeUserHasPInfo)
	}
	if m.doctor_schedule != nil {
		edges = append(edges, user.EdgeDoctorSchedule)
	}
	if m.user_have_telecoms != nil {
		edges = append(edges, user.EdgeUserHaveTelecoms)
	}
	if m.doctor_record_treatment != nil {
		edges = append(edges, user.EdgeDoctorRecordTreatment)
	}
	if m.user_have_treatment != nil {
		edges = append(edges, user.EdgeUserHaveTreatment)
	}
	if m.user_have_token != nil {
		edges = append(edges, user.EdgeUserHaveToken)
	}
	if m.user_send_message != nil {
		edges = append(edges, user.EdgeUserSendMessage)
	}
	if m.user_send_notification != nil {
		edges = append(edges, user.EdgeUserSendNotification)
	}
	if m.has_department != nil {
		edges = append(edges, user.EdgeHasDepartment)
	}
	if m.from_hospital != nil {
		edges = append(edges, user.EdgeFromHospital)
	}
	if m.user_have_disease != nil {
		edges = append(edges, user.EdgeUserHaveDisease)
	}
	if m.user_have_role != nil {
		edges = append(edges, user.EdgeUserHaveRole)
	}
	if m.who_is_in_this_chat != nil {
		edges = append(edges, user.EdgeWhoIsInThisChat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDoctorHasCertification:
		ids := make([]ent.Value, 0, len(m.doctor_has_certification))
		for id := range m.doctor_has_certification {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHasPInfo:
		ids := make([]ent.Value, 0, len(m.user_has_PInfo))
		for id := range m.user_has_PInfo {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDoctorSchedule:
		ids := make([]ent.Value, 0, len(m.doctor_schedule))
		for id := range m.doctor_schedule {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveTelecoms:
		ids := make([]ent.Value, 0, len(m.user_have_telecoms))
		for id := range m.user_have_telecoms {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDoctorRecordTreatment:
		ids := make([]ent.Value, 0, len(m.doctor_record_treatment))
		for id := range m.doctor_record_treatment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveTreatment:
		ids := make([]ent.Value, 0, len(m.user_have_treatment))
		for id := range m.user_have_treatment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveToken:
		ids := make([]ent.Value, 0, len(m.user_have_token))
		for id := range m.user_have_token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSendMessage:
		ids := make([]ent.Value, 0, len(m.user_send_message))
		for id := range m.user_send_message {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSendNotification:
		ids := make([]ent.Value, 0, len(m.user_send_notification))
		for id := range m.user_send_notification {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHasDepartment:
		if id := m.has_department; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFromHospital:
		if id := m.from_hospital; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserHaveDisease:
		ids := make([]ent.Value, 0, len(m.user_have_disease))
		for id := range m.user_have_disease {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveRole:
		ids := make([]ent.Value, 0, len(m.user_have_role))
		for id := range m.user_have_role {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWhoIsInThisChat:
		ids := make([]ent.Value, 0, len(m.who_is_in_this_chat))
		for id := range m.who_is_in_this_chat {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removeddoctor_has_certification != nil {
		edges = append(edges, user.EdgeDoctorHasCertification)
	}
	if m.removeduser_has_PInfo != nil {
		edges = append(edges, user.EdgeUserHasPInfo)
	}
	if m.removeddoctor_schedule != nil {
		edges = append(edges, user.EdgeDoctorSchedule)
	}
	if m.removeduser_have_telecoms != nil {
		edges = append(edges, user.EdgeUserHaveTelecoms)
	}
	if m.removeddoctor_record_treatment != nil {
		edges = append(edges, user.EdgeDoctorRecordTreatment)
	}
	if m.removeduser_have_treatment != nil {
		edges = append(edges, user.EdgeUserHaveTreatment)
	}
	if m.removeduser_have_token != nil {
		edges = append(edges, user.EdgeUserHaveToken)
	}
	if m.removeduser_send_message != nil {
		edges = append(edges, user.EdgeUserSendMessage)
	}
	if m.removeduser_send_notification != nil {
		edges = append(edges, user.EdgeUserSendNotification)
	}
	if m.removeduser_have_disease != nil {
		edges = append(edges, user.EdgeUserHaveDisease)
	}
	if m.removeduser_have_role != nil {
		edges = append(edges, user.EdgeUserHaveRole)
	}
	if m.removedwho_is_in_this_chat != nil {
		edges = append(edges, user.EdgeWhoIsInThisChat)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDoctorHasCertification:
		ids := make([]ent.Value, 0, len(m.removeddoctor_has_certification))
		for id := range m.removeddoctor_has_certification {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHasPInfo:
		ids := make([]ent.Value, 0, len(m.removeduser_has_PInfo))
		for id := range m.removeduser_has_PInfo {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDoctorSchedule:
		ids := make([]ent.Value, 0, len(m.removeddoctor_schedule))
		for id := range m.removeddoctor_schedule {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveTelecoms:
		ids := make([]ent.Value, 0, len(m.removeduser_have_telecoms))
		for id := range m.removeduser_have_telecoms {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDoctorRecordTreatment:
		ids := make([]ent.Value, 0, len(m.removeddoctor_record_treatment))
		for id := range m.removeddoctor_record_treatment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveTreatment:
		ids := make([]ent.Value, 0, len(m.removeduser_have_treatment))
		for id := range m.removeduser_have_treatment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveToken:
		ids := make([]ent.Value, 0, len(m.removeduser_have_token))
		for id := range m.removeduser_have_token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSendMessage:
		ids := make([]ent.Value, 0, len(m.removeduser_send_message))
		for id := range m.removeduser_send_message {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSendNotification:
		ids := make([]ent.Value, 0, len(m.removeduser_send_notification))
		for id := range m.removeduser_send_notification {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveDisease:
		ids := make([]ent.Value, 0, len(m.removeduser_have_disease))
		for id := range m.removeduser_have_disease {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserHaveRole:
		ids := make([]ent.Value, 0, len(m.removeduser_have_role))
		for id := range m.removeduser_have_role {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWhoIsInThisChat:
		ids := make([]ent.Value, 0, len(m.removedwho_is_in_this_chat))
		for id := range m.removedwho_is_in_this_chat {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.cleareddoctor_has_certification {
		edges = append(edges, user.EdgeDoctorHasCertification)
	}
	if m.cleareduser_has_PInfo {
		edges = append(edges, user.EdgeUserHasPInfo)
	}
	if m.cleareddoctor_schedule {
		edges = append(edges, user.EdgeDoctorSchedule)
	}
	if m.cleareduser_have_telecoms {
		edges = append(edges, user.EdgeUserHaveTelecoms)
	}
	if m.cleareddoctor_record_treatment {
		edges = append(edges, user.EdgeDoctorRecordTreatment)
	}
	if m.cleareduser_have_treatment {
		edges = append(edges, user.EdgeUserHaveTreatment)
	}
	if m.cleareduser_have_token {
		edges = append(edges, user.EdgeUserHaveToken)
	}
	if m.cleareduser_send_message {
		edges = append(edges, user.EdgeUserSendMessage)
	}
	if m.cleareduser_send_notification {
		edges = append(edges, user.EdgeUserSendNotification)
	}
	if m.clearedhas_department {
		edges = append(edges, user.EdgeHasDepartment)
	}
	if m.clearedfrom_hospital {
		edges = append(edges, user.EdgeFromHospital)
	}
	if m.cleareduser_have_disease {
		edges = append(edges, user.EdgeUserHaveDisease)
	}
	if m.cleareduser_have_role {
		edges = append(edges, user.EdgeUserHaveRole)
	}
	if m.clearedwho_is_in_this_chat {
		edges = append(edges, user.EdgeWhoIsInThisChat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDoctorHasCertification:
		return m.cleareddoctor_has_certification
	case user.EdgeUserHasPInfo:
		return m.cleareduser_has_PInfo
	case user.EdgeDoctorSchedule:
		return m.cleareddoctor_schedule
	case user.EdgeUserHaveTelecoms:
		return m.cleareduser_have_telecoms
	case user.EdgeDoctorRecordTreatment:
		return m.cleareddoctor_record_treatment
	case user.EdgeUserHaveTreatment:
		return m.cleareduser_have_treatment
	case user.EdgeUserHaveToken:
		return m.cleareduser_have_token
	case user.EdgeUserSendMessage:
		return m.cleareduser_send_message
	case user.EdgeUserSendNotification:
		return m.cleareduser_send_notification
	case user.EdgeHasDepartment:
		return m.clearedhas_department
	case user.EdgeFromHospital:
		return m.clearedfrom_hospital
	case user.EdgeUserHaveDisease:
		return m.cleareduser_have_disease
	case user.EdgeUserHaveRole:
		return m.cleareduser_have_role
	case user.EdgeWhoIsInThisChat:
		return m.clearedwho_is_in_this_chat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeHasDepartment:
		m.ClearHasDepartment()
		return nil
	case user.EdgeFromHospital:
		m.ClearFromHospital()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDoctorHasCertification:
		m.ResetDoctorHasCertification()
		return nil
	case user.EdgeUserHasPInfo:
		m.ResetUserHasPInfo()
		return nil
	case user.EdgeDoctorSchedule:
		m.ResetDoctorSchedule()
		return nil
	case user.EdgeUserHaveTelecoms:
		m.ResetUserHaveTelecoms()
		return nil
	case user.EdgeDoctorRecordTreatment:
		m.ResetDoctorRecordTreatment()
		return nil
	case user.EdgeUserHaveTreatment:
		m.ResetUserHaveTreatment()
		return nil
	case user.EdgeUserHaveToken:
		m.ResetUserHaveToken()
		return nil
	case user.EdgeUserSendMessage:
		m.ResetUserSendMessage()
		return nil
	case user.EdgeUserSendNotification:
		m.ResetUserSendNotification()
		return nil
	case user.EdgeHasDepartment:
		m.ResetHasDepartment()
		return nil
	case user.EdgeFromHospital:
		m.ResetFromHospital()
		return nil
	case user.EdgeUserHaveDisease:
		m.ResetUserHaveDisease()
		return nil
	case user.EdgeUserHaveRole:
		m.ResetUserHaveRole()
		return nil
	case user.EdgeWhoIsInThisChat:
		m.ResetWhoIsInThisChat()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
